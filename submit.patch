diff --git a/kern/arch/mips/include/trapframe.h b/kern/arch/mips/include/trapframe.h
index 993b10c..c3c63dd 100644
--- a/kern/arch/mips/include/trapframe.h
+++ b/kern/arch/mips/include/trapframe.h
@@ -77,6 +77,8 @@ struct trapframe {
 	uint32_t tf_epc;	/* coprocessor 0 epc register */
 };
 
+void clonetrapframe(struct trapframe *, struct trapframe*);
+
 /*
  * MIPS exception codes.
  */
diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
index 0f773bd..70b882e 100644
--- a/kern/arch/mips/syscall/syscall.c
+++ b/kern/arch/mips/syscall/syscall.c
@@ -35,6 +35,7 @@
 #include <thread.h>
 #include <current.h>
 #include <syscall.h>
+#include <copyinout.h>
 
 
 /*
@@ -96,22 +97,99 @@ syscall(struct trapframe *tf)
 	 * deal with it except for calls that return other values, 
 	 * like write.
 	 */
-
+	int32_t pid;
 	retval = 0;
+	int32_t offsethigh, offsetlow;	//offsethigh is the most significant 32bits, offsetlow is the least.
+	off_t pos;
 
 	switch (callno) {
-	    case SYS_reboot:
+	case SYS_reboot:
 		err = sys_reboot(tf->tf_a0);
 		break;
 
-	    case SYS___time:
+	case SYS___time:
 		err = sys___time((userptr_t)tf->tf_a0,
-				 (userptr_t)tf->tf_a1);
+				(userptr_t)tf->tf_a1);
+		break;
+
+		/******************************FILE SYSTEM CALLS**************************************/
+	case SYS_open:
+		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
+		break;
+
+	case SYS_read:
+		err = sys_read(tf->tf_a0, (userptr_t) tf->tf_a1 , tf->tf_a2, &retval/*bytesread*/ );
+		break;
+
+	case SYS_write:
+		err = sys_write(tf->tf_a0, (userptr_t) tf->tf_a1 , tf->tf_a2, &retval/* byteswritten*/);
+		break;
+
+	case SYS_lseek:
+		//TBD
+		pos = tf->tf_a2;	//assuming here that a2 contains the MS 32 bits. NEED TO VERIFY
+		pos = pos << 32;
+		pos = pos | tf->tf_a3;
+		//TBD;
+
+		err = sys_lseek(tf->tf_a0, pos, tf->tf_sp, &offsethigh, &offsetlow);
+
+		if(err==0)
+		{
+			retval = offsethigh;
+			tf->tf_v1 = offsetlow;
+		}
+
+		break;
+
+	case SYS_close:
+		err = sys_close(tf->tf_a0);
 		break;
 
-	    /* Add stuff here */
- 
-	    default:
+	case SYS_dup2:
+		//DINT UNDERSTAND THE MAN SPECS NEED TO CLARIFY
+		err = sys_dup2(tf->tf_a0, tf->tf_a1,&retval);
+
+		break;
+
+	case SYS_chdir:
+		err = sys_chdir((userptr_t) tf->tf_a0);
+		break;
+
+	case SYS___getcwd:
+		err = sys___getcwd((userptr_t )tf->tf_a0, tf->tf_a1, &retval);
+		break;
+
+		/*****************************************END FILE SYSTEM CALLS**************************************/
+
+		/**************************************** START OF PROCESS SYSTEM CALLS ***************************/
+	case SYS_getpid:
+		pid = sys_getpid();
+		retval = (int32_t)pid;
+		err = 0;
+		break;
+
+	case SYS_fork:
+		err = sys_fork(tf, &retval);
+		break;
+	case SYS_waitpid:
+		err = sys_waitpid(tf->tf_a0,(userptr_t)tf->tf_a1,tf->tf_a2,&retval,0);
+		//copyout(&status,(userptr_t)tf->tf_a1,sizeof(int));
+		break;
+	case SYS__exit:
+		sys_exit(tf->tf_a0);
+		break;
+	case SYS_execv:
+		err=sys_execv((userptr_t)tf->tf_a0,(userptr_t)tf->tf_a1);
+		break;
+
+
+
+		/*****************************************END OF PROCESS SYSTEM CALLS******************/
+
+		/* Add stuff here */
+
+	default:
 		kprintf("Unknown syscall %d\n", callno);
 		err = ENOSYS;
 		break;
@@ -132,12 +210,12 @@ syscall(struct trapframe *tf)
 		tf->tf_v0 = retval;
 		tf->tf_a3 = 0;      /* signal no error */
 	}
-	
+
 	/*
 	 * Now, advance the program counter, to avoid restarting
 	 * the syscall over and over again.
 	 */
-	
+
 	tf->tf_epc += 4;
 
 	/* Make sure the syscall code didn't forget to lower spl */
diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
index d527f61..451173d 100644
--- a/kern/conf/conf.kern
+++ b/kern/conf/conf.kern
@@ -367,6 +367,8 @@ file      vfs/devnull.c
 file      syscall/loadelf.c
 file      syscall/runprogram.c
 file      syscall/time_syscalls.c
+file      syscall/file_syscalls.c
+file	  syscall/proc_syscalls.c
 
 #
 # Startup and initialization
diff --git a/kern/include/synch.h b/kern/include/synch.h
index ac3714b..48e2d18 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -74,8 +74,10 @@ void V(struct semaphore *);
  */
 struct lock {
         char *lk_name;
-        // add what you need here
-        // (don't forget to mark things volatile as needed)
+    	struct wchan *lk_wchan;
+    	struct spinlock lk_lock;
+        volatile bool lk_held;
+        volatile struct thread *lk_holder;
 };
 
 struct lock *lock_create(const char *name);
@@ -113,7 +115,8 @@ void lock_destroy(struct lock *);
 
 struct cv {
         char *cv_name;
-        // add what you need here
+        struct wchan *cv_wchan;
+         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
 
@@ -143,6 +146,10 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
 
 struct rwlock {
         char *rwlock_name;
+        volatile int counter;
+        struct lock *writelock;
+        struct lock *transactionlock;
+        struct cv *cv_writer;
 };
 
 struct rwlock * rwlock_create(const char *);
diff --git a/kern/include/syscall.h b/kern/include/syscall.h
index befd3d8..7cab4e4 100644
--- a/kern/include/syscall.h
+++ b/kern/include/syscall.h
@@ -58,4 +58,23 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
 int sys_reboot(int code);
 int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
 
+//ASST2 File operation prototypes
+int sys_open(userptr_t filename, int flags, int32_t *fd, ...);
+int sys_read(int fd, userptr_t buf, size_t buflen, int32_t *bytesread);
+int sys_write(int fd, userptr_t buf, size_t nbytes, int32_t *byteswritten);
+int sys_lseek(int fd, off_t pos, int whence, int32_t *offsethigh, int32_t *offsetlow);
+int sys_close(int fd);
+int sys_dup2(int oldfd, int newfd, int *);
+int sys_chdir(userptr_t pathname);
+int sys___getcwd(userptr_t buf, size_t buflen, int32_t *ret);
+
+//ASST2 Process syscalls
+pid_t sys_getpid(void);
+int sys_fork(struct trapframe *ptf, pid_t *pid);
+int sys_execv(userptr_t program, userptr_t args);
+int sys_waitpid(pid_t pid, userptr_t status, int options,int*, int);
+void sys_exit(int exitcode);
+
+void child_fork(void* data1, unsigned long data2);
+
 #endif /* _SYSCALL_H_ */
diff --git a/kern/include/test.h b/kern/include/test.h
index 240d583..c0c72d2 100644
--- a/kern/include/test.h
+++ b/kern/include/test.h
@@ -66,7 +66,6 @@ void whalemating_cleanup(void);
 void inQuadrant(int);
 void leaveIntersection(void);
 int stoplight(int, char **);
-
 void gostraight(void *, unsigned long);
 void turnleft(void *, unsigned long);
 void turnright(void *, unsigned long);
@@ -105,8 +104,8 @@ int mallocstress(int, char **);
 int nettest(int, char **);
 
 /* Routine for running a user-level program. */
-int runprogram(char *progname);
-
+int runprogram(char *progname,char**, unsigned long);
+int kstrcpy(char* src, char* dest);
 /* Kernel menu system. */
 void menu(char *argstr);
 
diff --git a/kern/include/thread.h b/kern/include/thread.h
index 86706ca..05f5f0f 100644
--- a/kern/include/thread.h
+++ b/kern/include/thread.h
@@ -38,6 +38,8 @@
 
 #include <spinlock.h>
 #include <threadlist.h>
+#include <limits.h>
+#include <synch.h>
 
 struct addrspace;
 struct cpu;
@@ -100,6 +102,10 @@ struct thread {
 	bool t_in_interrupt;		/* Are we in an interrupt? */
 	int t_curspl;			/* Current spl*() state */
 	int t_iplhigh_count;		/* # of times IPL has been raised */
+	pid_t pid;
+	pid_t ppid;
+	//Anand: Added for waitpid implementation
+	//struct semaphore* exitSemaphore;
 
 	/*
 	 * Public fields
@@ -112,8 +118,36 @@ struct thread {
 	struct vnode *t_cwd;		/* current working directory */
 
 	/* add more here as needed */
+	//TODO :need to set this to NULL somewhere
+	struct filehandle* filetable[OPEN_MAX];	// remember that 0, 1 and 2 are taken
 };
 
+//Move this out of here later
+struct filehandle
+{
+	int open_mode;
+	off_t offset;
+	struct vnode *fileobject;
+	struct lock* lk_fileaccess;
+	int refcount;
+};
+
+struct pidentry
+{
+	struct thread* thread;
+	struct semaphore *sem;
+	int exitstatus;
+};
+
+int createfd(struct thread* thread);
+
+struct pidentry* g_pidlist[PID_MAX];
+//int exitStatusCode[PID_MAX];
+
+struct lock* g_lk_pid;
+int createpid(struct thread* newthread, pid_t *ret);
+
+struct semaphore *g_runprogsem;
 /* Call once during system startup to allocate data structures. */
 void thread_bootstrap(void);
 
diff --git a/kern/include/uio.h b/kern/include/uio.h
index 5d97c48..761cad7 100644
--- a/kern/include/uio.h
+++ b/kern/include/uio.h
@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
 void uio_kinit(struct iovec *, struct uio *,
 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
 
+void uio_uinit(struct iovec *, struct uio *,
+	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+
 
 #endif /* _UIO_H_ */
diff --git a/kern/include/vfs.h b/kern/include/vfs.h
index 42f37a5..48fe403 100644
--- a/kern/include/vfs.h
+++ b/kern/include/vfs.h
@@ -114,6 +114,10 @@ int vfs_rename(char *oldpath, char *newpath);
 int vfs_chdir(char *path);
 int vfs_getcwd(struct uio *buf);
 
+
+int vfs_read(struct vnode *vn, struct uio *uio);
+int vfs_write(struct vnode *vn, struct uio *uio);
+off_t vfs_lseek(struct vnode *vn, off_t pos);
 /*
  * Misc
  *
diff --git a/kern/lib/uio.c b/kern/lib/uio.c
index 594fe96..40d1af5 100644
--- a/kern/lib/uio.c
+++ b/kern/lib/uio.c
@@ -163,3 +163,23 @@ uio_kinit(struct iovec *iov, struct uio *u,
 	u->uio_rw = rw;
 	u->uio_space = NULL;
 }
+
+/*
+ * Convenience function to initialize an iovec and uio for kernel I/O.
+ */
+
+void
+uio_uinit(struct iovec *iov, struct uio *u,
+	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+{
+	iov->iov_ubase = kbuf;
+	iov->iov_len = len;
+	u->uio_iov = iov;
+	u->uio_iovcnt = 1;
+	u->uio_offset = pos;
+	u->uio_resid = len;
+	u->uio_segflg = UIO_USERSPACE;
+	u->uio_rw = rw;
+	u->uio_space = NULL;
+	u->uio_space = curthread->t_addrspace;
+}
diff --git a/kern/startup/main.c b/kern/startup/main.c
index be4c4b8..1ebfa47 100644
--- a/kern/startup/main.c
+++ b/kern/startup/main.c
@@ -100,7 +100,7 @@ boot(void)
 	kprintf("%s", harvard_copyright);
 	kprintf("\n");
 
-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+	kprintf("anandpra@buffalo.edu's system version %s (%s #%d)\n", 
 		GROUP_VERSION, buildconfig, buildversion);
 	kprintf("\n");
 
@@ -126,7 +126,7 @@ boot(void)
 
 	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
 	vfs_setbootfs("emu0");
-
+	g_lk_pid=lock_create("createPIDLock");
 
 	/*
 	 * Make sure various things aren't screwed up.
@@ -196,6 +196,8 @@ sys_reboot(int code)
 	return 0;
 }
 
+
+
 /*
  * Kernel main. Boot up, then fork the menu thread; wait for a reboot
  * request, and then shut down.
diff --git a/kern/startup/menu.c b/kern/startup/menu.c
index 6c71551..9274d83 100644
--- a/kern/startup/menu.c
+++ b/kern/startup/menu.c
@@ -81,6 +81,8 @@ getinterval(time_t s1, uint32_t ns1, time_t s2, uint32_t ns2,
  * It copies the program name because runprogram destroys the copy
  * it gets by passing it to vfs_open(). 
  */
+
+
 static
 void
 cmd_progthread(void *ptr, unsigned long nargs)
@@ -100,13 +102,15 @@ cmd_progthread(void *ptr, unsigned long nargs)
 
 	strcpy(progname, args[0]);
 
-	result = runprogram(progname);
+	result = runprogram(progname,args, nargs);
 	if (result) {
 		kprintf("Running program %s failed: %s\n", args[0],
 			strerror(result));
 		return;
 	}
 
+	sys_exit(0);
+
 	/* NOTREACHED: runprogram only returns on error. */
 }
 
@@ -122,6 +126,9 @@ cmd_progthread(void *ptr, unsigned long nargs)
  * array and strings, until you do this a race condition exists
  * between that code and the menu input code.
  */
+
+
+
 static
 int
 common_prog(int nargs, char **args)
@@ -132,16 +139,28 @@ common_prog(int nargs, char **args)
 	kprintf("Warning: this probably won't work with a "
 		"synchronization-problems kernel.\n");
 #endif
+	g_runprogsem = sem_create("run prog sem",0);
 
+	struct thread *child = NULL;
 	result = thread_fork(args[0] /* thread name */,
 			cmd_progthread /* thread function */,
 			args /* thread arg */, nargs /* thread arg */,
-			NULL);
+			&child);
 	if (result) {
 		kprintf("thread_fork failed: %s\n", strerror(result));
 		return result;
 	}
 
+	P(g_runprogsem);
+	int *status = kmalloc(sizeof(int));
+	int pid;
+	result = sys_waitpid(2, (userptr_t)(&status),0, &pid, 1);
+	if (result) {
+			kprintf("wait on user thread failed: %s\n", strerror(result));
+			return result;
+	}
+	sem_destroy(g_runprogsem);
+
 	return 0;
 }
 
diff --git a/kern/synchprobs/drivers.c b/kern/synchprobs/drivers.c
index 02e336f..a4ba023 100644
--- a/kern/synchprobs/drivers.c
+++ b/kern/synchprobs/drivers.c
@@ -86,15 +86,15 @@ int whalemating(int nargs, char **args) {
 
 			switch (i) {
 			case 0:
-				snprintf(name, sizeof(name), "Male Whale Thread %d", (i * 3) + j);
+				snprintf(name, sizeof(name), "Male Whale Thread %d", (i * 10) + j);
 				err = thread_fork(name, male, whalematingMenuSemaphore, j, NULL);
 				break;
 			case 1:
-				snprintf(name, sizeof(name), "Female Whale Thread %d", (i * 3) + j);
+				snprintf(name, sizeof(name), "Female Whale Thread %d", (i * 10) + j);
 				err = thread_fork(name, female, whalematingMenuSemaphore, j, NULL);
 				break;
 			case 2:
-				snprintf(name, sizeof(name), "Matchmaker Whale Thread %d", (i * 3) + j);
+				snprintf(name, sizeof(name), "Matchmaker Whale Thread %d", (i * 10) + j);
 				err = thread_fork(name, matchmaker, whalematingMenuSemaphore, j, NULL);
 				break;
 			}
diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
index 81d2f0e..78082a2 100644
--- a/kern/synchprobs/problems.c
+++ b/kern/synchprobs/problems.c
@@ -47,63 +47,98 @@
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
 
+static void getquadrants(unsigned long, int *);
+
+struct cv *cvWaitingMales;
+struct cv *cvWaitingFemales;
+struct semaphore *semMale;
+struct semaphore *semFemale;
+struct lock *lkMale;
+struct lock *lkFemale;
+
+
 void whalemating_init() {
-  return;
+	cvWaitingMales = cv_create("waitingmales");
+	cvWaitingFemales = cv_create("waitingfemales");
+	semMale = sem_create("semMale",0);
+	semFemale = sem_create("semFemale",0);
+	lkMale = lock_create("lkMale");
+	lkFemale = lock_create("lkFemale");
+	return;
 }
 
 // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void whalemating_cleanup() {
-  return;
+	sem_destroy(semMale);
+	sem_destroy(semFemale);
+	cv_destroy(cvWaitingMales);
+	cv_destroy(cvWaitingFemales);
+	lock_destroy(lkMale);
+	lock_destroy(lkFemale);
+	return;
 }
 
 void
 male(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
-  (void)which;
-  
-  male_start();
-	// Implement this function 
-  male_end();
-
-  // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
-  // whalemating driver can return to the menu cleanly.
-  V(whalematingMenuSemaphore);
-  return;
+	(void)which;
+
+	male_start();
+	V(semMale);
+	lock_acquire(lkMale);
+	cv_wait(cvWaitingMales, lkMale);
+	lock_release(lkMale);
+	male_end();
+
+	// 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+	// whalemating driver can return to the menu cleanly.
+	V(whalematingMenuSemaphore);
+	return;
 }
 
 void
 female(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
-  (void)which;
-  
-  female_start();
-	// Implement this function 
-  female_end();
-  
-  // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
-  // whalemating driver can return to the menu cleanly.
-  V(whalematingMenuSemaphore);
-  return;
+	(void)which;
+
+	female_start();
+	V(semFemale);
+	lock_acquire(lkFemale);
+	cv_wait(cvWaitingFemales, lkFemale);
+	lock_release(lkFemale);
+
+	female_end();
+
+	// 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+	// whalemating driver can return to the menu cleanly.
+	V(whalematingMenuSemaphore);
+	return;
 }
 
 void
 matchmaker(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
-  (void)which;
-  
-  matchmaker_start();
-	// Implement this function 
-  matchmaker_end();
-  
-  // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
-  // whalemating driver can return to the menu cleanly.
-  V(whalematingMenuSemaphore);
-  return;
+	(void)which;
+
+	matchmaker_start();
+	P(semMale);
+	P(semFemale);
+	lock_acquire(lkMale);
+	lock_acquire(lkFemale);
+	cv_signal(cvWaitingMales,lkMale);
+
+	cv_signal(cvWaitingFemales,lkFemale);
+	matchmaker_end();
+
+	// 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+	// whalemating driver can return to the menu cleanly.
+	V(whalematingMenuSemaphore);
+	return;
 }
 
 /*
@@ -137,49 +172,106 @@ matchmaker(void *p, unsigned long which)
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
 
+struct lock *lkPlanning;
+struct lock *lkQuadrant[4];
+
 void stoplight_init() {
-  return;
+	lkQuadrant[0] = lock_create("lkZero");
+	lkQuadrant[1] = lock_create("lkOne");
+	lkQuadrant[2] = lock_create("lkTwo");
+	lkQuadrant[3] = lock_create("lkThree");
+	lkPlanning = lock_create("lkPlanning");
+	return;
 }
 
 // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void stoplight_cleanup() {
-  return;
+	lock_destroy(lkQuadrant[0]);
+	lock_destroy(lkQuadrant[1]);
+	lock_destroy(lkQuadrant[2]);
+	lock_destroy(lkQuadrant[3]);
+	lock_destroy(lkPlanning);
+	return;
+}
+
+void getquadrants(unsigned long direction, int* ret)
+{
+	ret[0] = direction;
+	ret[1] = (direction + 3) % 4;
+	ret[2] = (direction  + 2) % 4;
+
 }
 
 void
 gostraight(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
-  
-  // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
-  // stoplight driver can return to the menu cleanly.
-  V(stoplightMenuSemaphore);
-  return;
+
+	int quad[3];
+	getquadrants(direction, quad);
+
+	lock_acquire(lkPlanning);
+
+	lock_acquire(lkQuadrant[quad[0]]);
+	lock_acquire(lkQuadrant[quad[1]]);
+
+	lock_release(lkPlanning);
+	inQuadrant(quad[0]);
+	inQuadrant(quad[1]);
+	lock_release(lkQuadrant[quad[0]]);
+	leaveIntersection();
+	lock_release(lkQuadrant[quad[1]]);
+	// 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+	// stoplight driver can return to the menu cleanly.
+	V(stoplightMenuSemaphore);
+	return;
 }
 
 void
 turnleft(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
-  
-  // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
-  // stoplight driver can return to the menu cleanly.
-  V(stoplightMenuSemaphore);
-  return;
+	int quad[3];
+	getquadrants(direction, quad);
+
+	lock_acquire(lkPlanning);
+
+	lock_acquire(lkQuadrant[quad[0]]);
+	lock_acquire(lkQuadrant[quad[1]]);
+	lock_acquire(lkQuadrant[quad[2]]);
+
+	lock_release(lkPlanning);
+	inQuadrant(quad[0]);
+	inQuadrant(quad[1]);
+	lock_release(lkQuadrant[quad[0]]);
+	inQuadrant(quad[2]);
+	lock_release(lkQuadrant[quad[1]]);
+	leaveIntersection();
+	lock_release(lkQuadrant[quad[2]]);
+
+	// 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+	// stoplight driver can return to the menu cleanly.
+	V(stoplightMenuSemaphore);
+	return;
 }
 
 void
 turnright(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
 
-  // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
-  // stoplight driver can return to the menu cleanly.
-  V(stoplightMenuSemaphore);
-  return;
+	lock_acquire(lkPlanning);
+
+	lock_acquire(lkQuadrant[direction]);
+	inQuadrant(direction);
+	leaveIntersection();
+	lock_release(lkQuadrant[direction]);
+
+	lock_release(lkPlanning);
+	// 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+	// stoplight driver can return to the menu cleanly.
+	V(stoplightMenuSemaphore);
+	return;
 }
diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
new file mode 100644
index 0000000..b323c82
--- /dev/null
+++ b/kern/syscall/file_syscalls.c
@@ -0,0 +1,443 @@
+#include <types.h>
+#include <syscall.h>
+#include <lib.h>
+#include <vfs.h>
+#include <kern/errno.h>
+#include <thread.h>
+#include <kern/seek.h>
+#include <current.h>
+#include <lib.h>
+#include <kern/iovec.h>
+#include <uio.h>
+#include <kern/stat.h>
+#include <vnode.h>
+#include <copyinout.h>
+
+int createfd(struct thread* thread)
+{
+	int i;
+	for(i=3; i < (__OPEN_MAX) ; i++)
+		if (thread->filetable[i] == NULL )
+			return i;
+	return -1;	//file table full
+}
+/*
+Description
+open opens the file, device, or other kernel object named by the pathname filename. The flags argument specifies how to open the file. The optional mode argument is only meaningful in Unix (or if you choose to implement Unix-style security later on) and can be ignored.
+
+The flags argument should consist of one of
+
+    O_RDONLY		Open for reading only.
+    O_WRONLY		Open for writing only.
+    O_RDWR		Open for reading and writing.
+
+It may also have any of the following flags OR'd in:
+
+    O_CREAT		Create the file if it doesn't exist.
+    O_EXCL		Fail if the file already exists.
+    O_TRUNC		Truncate the file to length 0 upon open.
+    O_APPEND		Open the file in append mode.
+
+O_EXCL is only meaningful if O_CREAT is also used.
+
+O_APPEND causes all writes to the file to occur at the end of file, no matter what gets written to the file by whoever else. (This functionality may be optional; consult your course's assignments.)
+
+open returns a file handle suitable for passing to read, write, close, etc. This file handle must be greater than or equal to zero. Note that file handles 0 (STDIN_FILENO), 1 (STDOUT_FILENO), and 2 (STDERR_FILENO) are used in special ways and are typically assumed by user-level code to always be open.
+Return Values
+On success, open returns a nonnegative file handle. On error, -1 is returned, and errno is set according to the error encountered.
+Errors
+The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
+
+
+    ENODEV		The device prefix of filename did not exist.
+    ENOTDIR		A non-final component of filename was not a directory.
+    ENOENT		A non-final component of filename did not exist.
+    ENOENT		The named file does not exist, and O_CREAT was not specified.
+    EEXIST		The named file exists, and O_EXCL was specified.
+    EISDIR		The named object is a directory, and it was to be opened for writing.
+    EMFILE		The process's file table was full, or a process-specific limit on open files was reached.
+    ENFILE		The system file table is full, if such a thing exists, or a system-wide limit on open files was reached.
+    ENXIO		The named object is a block device with no mounted filesystem.
+    ENOSPC		The file was to be created, and the filesystem involved is full.
+    EINVAL		flags contained invalid values.
+    EIO		A hard I/O error occurred.
+    EFAULT		filename was an invalid pointer.
+ */
+int sys_open(userptr_t filename, int flags, int32_t *fd, ...)
+{
+	//	kprintf("FileName:%s, Flags:%d", (char*)filename, flags);
+	char kfilename[__PATH_MAX + __NAME_MAX + 1];
+
+
+	struct vnode *file_vnode;
+	int err;
+	size_t len;
+	err = copyinstr(filename, kfilename, __PATH_MAX + __NAME_MAX + 1, &len);
+	if(err)
+		return err;
+	err = vfs_open((char*)filename, flags, 0, &file_vnode);
+	if(err)
+		return err;
+	//No error we got a vnode now create a filediscriptor for it.
+	//TBD: we may not need to create a file discriptor
+	struct thread* cthread = (struct thread*)curthread;
+	*fd = createfd(cthread);
+	if(*fd < 0)
+		return ENFILE;
+
+	//only create this if its not already there.
+	struct filehandle *fh = kmalloc(sizeof(struct filehandle));
+	if(fh==NULL)
+		panic("Memory allocation for file handle failed");
+	fh->fileobject = file_vnode;
+	fh->offset = 0;
+	fh->open_mode = flags;
+	fh->lk_fileaccess = lock_create("filelock");
+	fh->refcount = 1;
+
+	// *fd = addtofiletable(fh);	we'll set fd once we implement filetable;
+	cthread->filetable[*fd] = fh;
+	//panic("fail open failed");
+	return 0;
+}
+
+/*
+Description
+read reads up to buflen bytes from the file specified by fd, at the location in the file specified by the current seek position of the file, and stores them in the space pointed to by buf. The file must be open for reading.
+
+The current seek position of the file is advanced by the number of bytes read.
+
+Each read (or write) operation is atomic relative to other I/O to the same file.
+
+Return Values
+The count of bytes read is returned. This count should be positive. A return value of 0 should be construed as signifying end-of-file. On error, read returns -1 and sets errno to a suitable error code for the error condition encountered.
+
+Note that in some cases, particularly on devices, fewer than buflen (but greater than zero) bytes may be returned. This depends on circumstances and does not necessarily signify end-of-file.
+
+Errors
+The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
+
+
+    EBADF		fd is not a valid file descriptor, or was not opened for reading.
+    EFAULT		Part or all of the address space pointed to by buf is invalid.
+    EIO		A hardware I/O error occurred reading the data.
+ */
+int sys_read(int fd, userptr_t buf, size_t buflen, int32_t *bytesread)
+{
+	if(fd<0||fd>=OPEN_MAX)
+		return EBADF;
+	struct filehandle* fh;
+	struct thread *cur = (struct thread*)curthread;
+	fh = cur->filetable[fd];
+	if(fh == NULL || (fh->open_mode & 1)!=0 )
+		return EBADF;
+
+	struct iovec iov;
+	struct uio ku;
+	char *readbuf = (char*)kmalloc(buflen);
+	lock_acquire(fh->lk_fileaccess);
+	uio_kinit(&iov, &ku, readbuf, buflen, fh->offset, UIO_READ);
+
+	int err = vfs_read(fh->fileobject, &ku);
+	if(err)
+		return err;
+	*bytesread = buflen - ku.uio_resid;
+	if(*bytesread==0){
+		lock_release(fh->lk_fileaccess);
+		kfree(readbuf);
+		return 0;
+	}
+
+	fh->offset += *bytesread;
+
+	lock_release(fh->lk_fileaccess);
+	err = copyout(readbuf, buf, *bytesread);
+	if(err)
+		return err;
+
+	kfree(readbuf);
+	return 0;
+}
+
+/*
+Description
+write writes up to buflen bytes to the file specified by fd, at the location in the file specified by the current seek position of the file, taking the data from the space pointed to by buf. The file must be open for writing.
+
+The current seek position of the file is advanced by the number of bytes written.
+
+Each write (or read) operation is atomic relative to other I/O to the same file.
+
+Return Values
+The count of bytes written is returned. This count should be positive. A return value of 0 means that nothing could be written, but that no error occurred; this only occurs at end-of-file on fixed-size objects. On error, write returns -1 and sets errno to a suitable error code for the error condition encountered.
+
+Note that in some cases, particularly on devices, fewer than buflen (but greater than zero) bytes may be written. This depends on circumstances and does not necessarily signify end-of-file. In most cases, one should loop to make sure that all output has actually been written.
+
+Errors
+The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
+
+
+    EBADF		fd is not a valid file descriptor, or was not opened for writing.
+    EFAULT		Part or all of the address space pointed to by buf is invalid.
+    ENOSPC		There is no free space remaining on the filesystem containing the file.
+    EIO		A hardware I/O error occurred writing the data.
+ */
+int sys_write(int fd, userptr_t buf, size_t nbytes, int32_t *byteswritten)
+{
+	if(fd<0||fd>=OPEN_MAX)
+		return EBADF;
+	struct filehandle* fh;
+	struct thread *cur = (struct thread*)curthread;
+	fh = cur->filetable[fd];
+	if(fh == NULL || (fh->open_mode & 3)==0 )
+		return EBADF;
+	char *writebuf = (char* )kmalloc(nbytes+1);
+	int result = copyin(buf, writebuf, nbytes);
+	if(result)
+		return result;
+	struct iovec iov;
+	struct uio ku;
+	lock_acquire(fh->lk_fileaccess);
+	uio_kinit(&iov, &ku, writebuf, nbytes, fh->offset, UIO_WRITE);
+	//ku.uio_space = cur->t_addrspace;
+	int err = vfs_write(fh->fileobject, &ku);
+	if(err)
+		return err;
+	*byteswritten = ku.uio_offset - fh->offset;
+	fh->offset += *byteswritten;
+	lock_release(fh->lk_fileaccess);
+	kfree(writebuf);
+	return 0;
+}
+
+/*
+Description
+lseek alters the current seek position of the file handle filehandle, seeking to a new position based on pos and whence.
+
+If whence is
+
+    SEEK_SET, the new position is pos.
+    SEEK_CUR, the new position is the current position plus pos.
+    SEEK_END, the new position is the position of end-of-file plus pos.
+    anything else, lseek fails.
+
+Note that pos is a signed quantity.
+
+It is not meaningful to seek on certain objects (such as the console device). All seeks on these objects fail.
+
+Seek positions less than zero are invalid. Seek positions beyond EOF are legal.
+
+Note that each distinct open of a file should have an independent seek pointer.
+
+Return Values
+On success, lseek returns the new position. On error, -1 is returned, and errno is set according to the error encountered.
+Errors
+The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
+
+
+    EBADF		fd is not a valid file handle.
+    ESPIPE		fd refers to an object which does not support seeking.
+    EINVAL		whence is invalid.
+    EINVAL		The resulting seek position would be negative.
+ */
+int sys_lseek(int fd, off_t pos, int sp, int32_t *offsethigh, int32_t *offsetlow)
+{
+	if(fd<0||fd>=OPEN_MAX)
+		return EBADF;
+	if(fd<3)
+		return ESPIPE;
+	int whence;
+	int err = copyin((userptr_t)sp+16, &whence, sizeof(int32_t));
+
+	if(whence <0 || whence >2)
+		return EINVAL;
+	struct filehandle* fh;
+	struct thread *cur = (struct thread*)curthread;
+	fh = cur->filetable[fd];
+	if(fh == NULL )
+		return EBADF;
+	lock_acquire(fh->lk_fileaccess);
+	off_t newpos;
+	if(whence == SEEK_SET)
+		newpos = 0;
+	else if(whence == SEEK_END)
+	{
+		struct stat filestat;
+		VOP_STAT(fh->fileobject, &filestat);
+		newpos = filestat.st_size;
+	}
+	else
+	{
+		newpos = fh->offset;
+	}
+	err =vfs_lseek(fh->fileobject, newpos + pos);
+	if(err)
+		return err;
+	fh->offset = newpos + pos;
+	// else whence is SEEK_CUR
+
+	off_t ofst = fh->offset;
+	*offsetlow = (int32_t)ofst;
+	ofst = ofst >> 32;
+	*offsethigh = (int32_t)ofst;
+
+	lock_release(fh->lk_fileaccess);
+	return 0;
+}
+
+/*
+Description
+The file handle fd is closed. The same file handle may then be returned again from open, dup2, pipe, or similar calls.
+
+Other file handles are not affected in any way, even if they are attached to the same file.
+
+Return Values
+On success, close returns 0. On error, -1 is returned, and errno is set according to the error encountered.
+Errors
+The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
+
+
+    EBADF		fd is not a valid file handle.
+    EIO		A hard I/O error occurred.
+ */
+int sys_close(int fd)
+{
+	if(fd<0||fd>=OPEN_MAX)
+		return EBADF;
+	struct filehandle* fh;
+	struct thread *cur = (struct thread*)curthread;
+	fh = cur->filetable[fd];
+	if(fh == NULL)
+		return EBADF;
+	fh->refcount --;
+	if(fh->refcount == 0)
+	{
+		vfs_close(fh->fileobject);
+		kfree(fh);
+	}
+	cur->filetable[fd] = NULL;
+	//	while(1);
+	return 0;
+}
+
+/*
+ Description
+dup2 clones the file handle oldfd onto the file handle newfd. If newfd names an open file, that file is closed.
+
+The two handles refer to the same "open" of the file - that is, they are references to the same object and share the same seek pointer. Note that this is different from opening the same file twice.
+
+dup2 is most commonly used to relocate opened files onto STDIN_FILENO, STDOUT_FILENO, and/or STDERR_FILENO.
+
+Both filehandles must be non-negative.
+
+Using dup2 to clone a file handle onto itself has no effect.
+
+(The "2" in "dup2" arises from the existence of an older and less powerful Unix system call "dup".)
+Return Values
+dup2 returns newfd. On error, -1 is returned, and errno is set according to the error encountered.
+Errors
+The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
+
+
+    EBADF		oldfd is not a valid file handle, or newfd is a value that cannot be a valid file handle.
+    EMFILE		The process's file table was full, or a process-specific limit on open files was reached.
+ */
+int sys_dup2(int oldfd, int newfd, int * retval)
+{
+	//oldfd should be valid,newfd should be valid
+	//newfd location must be empty
+	//File table full or limit reached
+	if(oldfd<0 ||oldfd >=__OPEN_MAX){
+		return EBADF;
+	}
+	struct filehandle* fh;
+	struct thread *cur = (struct thread*)curthread;
+	fh = cur->filetable[oldfd];
+	if(fh == NULL){
+		return EBADF;
+	}
+	if(newfd<0||newfd>=__OPEN_MAX){
+		return EBADF;
+	}else{
+		fh = cur->filetable[newfd];
+	    if((newfd!=oldfd)&&fh != NULL){
+	            sys_close(newfd);
+	        }
+		cur->filetable[newfd] = cur->filetable[oldfd];
+		*retval=newfd;
+		return 0;
+	}
+
+}
+
+/*
+ * Description
+The current directory of the current process is set to the directory named by pathname.
+
+Return Values
+On success, chdir returns 0. On error, -1 is returned, and errno is set according to the error encountered.
+Errors
+The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
+
+
+    ENODEV		The device prefix of pathname did not exist.
+    ENOTDIR		A non-final component of pathname was not a directory.
+    ENOTDIR		pathname did not refer to a directory.
+    ENOENT		pathname did not exist.
+    EIO		A hard I/O error occurred.
+    EFAULT		pathname was an invalid pointer.
+ */
+int sys_chdir(userptr_t pathname)
+{
+	char kfilename[__PATH_MAX + __NAME_MAX + 1];
+	int err;
+	size_t len;
+	err = copyinstr(pathname, kfilename, __PATH_MAX + __NAME_MAX + 1, &len);
+	if(err)
+		return err;
+	//didn use kfilename?
+	err = vfs_chdir((char*)kfilename);
+	if(err)
+		return err;
+
+	return 0;
+}
+
+
+/*
+Description
+The name of the current directory is computed and stored in buf, an area of size buflen. The length of data actually stored, which must be non-negative, is returned.
+
+Note: this call behaves like read - the name stored in buf is not 0-terminated.
+
+This function is not meant to be called except by the C library; application programmers should use getcwd instead.
+Return Values
+On success, __getcwd returns the length of the data returned. On error, -1 is returned, and errno is set according to the error encountered.
+Errors
+The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
+
+
+    ENOENT		A component of the pathname no longer exists.
+    EIO			A hard I/O error occurred.
+    EFAULT		buf points to an invalid address.
+ */
+int sys___getcwd(userptr_t buf, size_t buflen, int32_t *ret)
+{
+	if(buflen > PATH_MAX)
+		buflen = PATH_MAX;
+	//	struct thread *cur = (struct thread*)curthread;
+	struct iovec iov;
+	struct uio ku;
+	char *readbuf = (char*)kmalloc(buflen);
+	uio_kinit(&iov, &ku, readbuf, buflen, 0, UIO_READ);
+	int err = vfs_getcwd(&ku);
+	if(err)
+		return err;
+	*ret = buflen - ku.uio_resid;
+	err = copyout(readbuf, buf, *ret);
+	if(err)
+		return err;
+
+	kfree(readbuf);
+
+	return *ret;
+}
diff --git a/kern/syscall/proc_syscalls.c b/kern/syscall/proc_syscalls.c
new file mode 100644
index 0000000..85d19e7
--- /dev/null
+++ b/kern/syscall/proc_syscalls.c
@@ -0,0 +1,493 @@
+#include <types.h>
+#include <syscall.h>
+#include <kern/errno.h>
+#include <kern/fcntl.h>
+#include <lib.h>
+#include <thread.h>
+#include <current.h>
+#include <addrspace.h>
+#include <vm.h>
+#include <vfs.h>
+#include <syscall.h>
+#include <test.h>
+#include <mips/trapframe.h>
+#include <synch.h>
+#include <copyinout.h>
+#include <kern/wait.h>
+void clonetrapframe(struct trapframe *inframe, struct trapframe *returnframe)
+{
+	//struct trapframe* returnframe = kmalloc(sizeof(struct trapframe));
+
+	returnframe->tf_vaddr = inframe->tf_vaddr;	/* coprocessor 0 vaddr register */
+	returnframe->tf_status = inframe->tf_status;	/* coprocessor 0 status register */
+	returnframe->tf_cause = inframe->tf_cause;	/* coprocessor 0 cause register */
+	returnframe->tf_lo = inframe->tf_lo;
+	returnframe->tf_hi = inframe->tf_hi;
+	returnframe->tf_ra = inframe->tf_ra;		/* Saved register 31 */
+	returnframe->tf_at = inframe->tf_at;		/* Saved register 1 (AT) */
+	returnframe->tf_v0 = inframe->tf_v0;		/* Saved register 2 (v0) */
+	returnframe->tf_v1 = inframe->tf_v1;		/* etc. */
+	returnframe->tf_a0 = inframe->tf_a0;
+	returnframe->tf_a1 = inframe->tf_a1;
+	returnframe->tf_a2 = inframe->tf_a2;
+	returnframe->tf_a3 = inframe->tf_a3;
+	returnframe->tf_t0 = inframe->tf_t0;
+	returnframe->tf_t1 = inframe->tf_t1;
+	returnframe->tf_t2 = inframe->tf_t2;
+	returnframe->tf_t3 = inframe->tf_t3;
+	returnframe->tf_t4 = inframe->tf_t4;
+	returnframe->tf_t5 = inframe->tf_t5;
+	returnframe->tf_t6 = inframe->tf_t6;
+	returnframe->tf_t7 = inframe->tf_t7;
+	returnframe->tf_s0 = inframe->tf_s0;
+	returnframe->tf_s1 = inframe->tf_s1;
+	returnframe->tf_s2 = inframe->tf_s2;
+	returnframe->tf_s3 = inframe->tf_s3;
+	returnframe->tf_s4 = inframe->tf_s4;
+	returnframe->tf_s5 = inframe->tf_s5;
+	returnframe->tf_s6 = inframe->tf_s6;
+	returnframe->tf_s7 = inframe->tf_s7;
+	returnframe->tf_t8 = inframe->tf_t8;
+	returnframe->tf_t9 = inframe->tf_t9;
+	returnframe->tf_k0 = inframe->tf_k0;		/* dummy (see exception.S comments) */
+	returnframe->tf_k1 = inframe->tf_k1;		/* dummy */
+	returnframe->tf_gp = inframe->tf_gp;
+	returnframe->tf_sp = inframe->tf_sp;
+	returnframe->tf_s8 = inframe->tf_s8;
+	returnframe->tf_epc = inframe->tf_epc;
+
+	//return returnframe;
+}
+
+/*
+ *
+ * Name
+getpid - get process id
+Library
+Standard C Library (libc, -lc)
+Synopsis
+#include <unistd.h>
+
+pid_t
+getpid(void);
+Description
+getpid returns the process id of the current process.
+Errors
+getpid does not fail.
+ */
+
+pid_t sys_getpid(void)
+{
+	return curthread->pid;
+}
+
+
+/*
+ *
+ * Name
+fork - copy the current process
+Library
+Standard C Library (libc, -lc)
+Synopsis
+#include <unistd.h>
+
+pid_t
+fork(void);
+Description
+fork duplicates the currently running process. The two copies are identical, except that one (the "new" one, or "child"), has a new, unique process id, and in the other (the "parent") the process id is unchanged.
+
+The process id must be greater than 0.
+
+The two processes do not share memory or open file tables; this state is copied into the new process, and subsequent modification in one process does not affect the other.
+
+However, the file handle objects the file tables point to are shared, so, for instance, calls to lseek in one process can affect the other.
+
+Return Values
+On success, fork returns twice, once in the parent process and once in the child process. In the child process, 0 is returned. In the parent process, the process id of the new child process is returned.
+
+On error, no new process is created, fork only returns once, returning -1, and errno is set according to the error encountered.
+Errors
+The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
+
+
+    EMPROC		The current user already has too many processes.
+    ENPROC		There are already too many processes on the system.
+    ENOMEM		Sufficient virtual memory for the new process was not available.
+ */
+
+struct message
+{
+	struct trapframe *tf;
+	struct addrspace *as;
+	struct semaphore *sem;
+	int *pid;
+};
+
+int sys_fork(struct trapframe *ptf, pid_t *pid)
+{
+	//clone the parent trapframe
+
+	//TODO: Currently leaking this part of memory need to fix this
+	//struct trapframe *tf = kmalloc(sizeof(struct trapframe));
+	//clonetrapframe(ptf, tf);
+
+	struct addrspace *childas = NULL;
+	int err = as_copy(curthread->t_addrspace, &childas);	//copy parent address space
+	if(err)
+		return err;
+	struct message* msg = kmalloc(sizeof(struct message));
+
+	struct semaphore* s = sem_create("forksem",0);
+	msg->as = childas;
+	msg->tf= ptf;
+	msg->sem = s;
+	msg->pid = kmalloc(sizeof(int));
+	struct thread* child=NULL;
+	err = thread_fork("child", &child_fork, (void*)msg, 0, &child );
+	P(s);
+	*pid = *(msg->pid);
+	kfree(msg->sem);
+	kfree(msg->pid);
+	kfree(msg);
+
+	if(err)
+		return err;
+	return 0;
+}
+
+/*
+ * Name
+execv - execute a program
+Library
+Standard C Library (libc, -lc)
+Synopsis
+#include <unistd.h>
+
+int
+execv(const char *program, char **args);
+Description
+execv replaces the currently executing program with a newly loaded program image. This occurs within one process; the process id is unchanged.
+
+The pathname of the program to run is passed as program. The args argument is an array of 0-terminated strings. The array itself should be terminated by a NULL pointer.
+
+The argument strings should be copied into the new process as the new process's argv[] array. In the new process, argv[argc] must be NULL.
+
+By convention, argv[0] in new processes contains the name that was used to invoke the program. This is not necessarily the same as program, and furthermore is only a convention and should not be enforced by the kernel.
+
+The process file table and current working directory are not modified by execve.
+Return Values
+On success, execv does not return; instead, the new program begins executing. On failure, execv returns -1, and sets errno to a suitable error code for the error condition encountered.
+Errors
+The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
+
+
+    ENODEV		The device prefix of program did not exist.
+    ENOTDIR		A non-final component of program was not a directory.
+    ENOENT		program did not exist.
+    EISDIR		program is a directory.
+    ENOEXEC		program is not in a recognizable executable file format, was for the wrong platform, or contained invalid fields.
+    ENOMEM		Insufficient virtual memory is available.
+    E2BIG		The total size of the argument strings is too large.
+    EIO		A hard I/O error occurred.
+    EFAULT		One of the args is an invalid pointer.
+ */
+
+int sys_execv(userptr_t prog, userptr_t argsptr)
+{
+	char *program = kmalloc(1000);
+	size_t proglen;
+
+	int err = copyin(argsptr, program,1); // doing this just to make sure its valid address
+	if(err)
+	{
+			kfree(program);
+			return EFAULT;
+	}
+
+	err = copyinstr(prog, program, 1000, &proglen);
+	if(err)
+	{
+			kfree(program);
+			return EFAULT;
+	}
+	if(err)
+	{
+		kfree(program);
+		return EFAULT;
+	}
+	char** args=(char**)argsptr;
+	struct vnode *v;
+	vaddr_t entrypoint, stackptr;
+	int result;
+
+	//Copy the arguments into kernel buffer
+	unsigned long j=0;
+	size_t strlen=0;
+	int size=0;
+	unsigned long argc;
+	//Calculate the size of the array to allocate
+	char * tempArgs=kmalloc(1000);
+
+	while(args[j]!=NULL){
+		//strlen = kstrcpy(args[j], tempArgs);//
+		err = copyinstr((userptr_t)(args[j]), tempArgs, 1000,&strlen);
+		if(err)
+		{
+			kfree(tempArgs);
+			return EFAULT;
+		}
+		strlen=strlen + 4 - strlen%4;
+		size+=strlen;
+		j++;
+	}
+	argc=j;
+	//Add space for 4 integers
+	size+=argc*4;
+	size+=4;//for Null
+
+	char * kargv= kmalloc(size);
+	int top=argc*4+4;
+	j=0;
+	while(args[j]!=NULL){
+		strlen=0;
+		*((int*)(kargv + j*4))=top;
+	//	strlen = kstrcpy(args[j], kargv+top);//
+		copyinstr((userptr_t)args[j], kargv+top, 1000,&strlen);
+		top+=strlen;
+		while(top%4!=0){
+			*(kargv+top)='\0';
+			top++;
+		}
+		j++;
+	}
+	int * ka = (int*)(kargv + j*4);
+	*(ka)=0;
+	//kargv is constructed
+
+	/* Open the file. */
+	result = vfs_open((char*)program, O_RDONLY, 0, &v);
+	if (result) {
+		return result;
+	}
+
+	/* Load the executable. */
+	result = load_elf(v, &entrypoint);
+	if (result) {
+		/* thread_exit destroys curthread->t_addrspace */
+		vfs_close(v);
+		return result;
+	}
+
+	/* Done with the file now. */
+	vfs_close(v);
+
+	/* Define the user stack in the address space */
+	result = as_define_stack(curthread->t_addrspace, &stackptr);
+	if (result) {
+		/* thread_exit destroys curthread->t_addrspace */
+		return result;
+	}
+
+	//Copy the arguments to userstack
+	j=0;
+	int * userAddr=(int *)(stackptr-size);
+
+	while(j<argc){
+		ka = (int*)(kargv + j*4);
+		*ka=*ka+(int)userAddr;
+		//userAddr+=2;
+		j++;
+	}
+	copyout(kargv, (userptr_t)userAddr, (size_t)size);
+	//Copied to user space
+	kfree(tempArgs);
+	kfree(kargv);
+	/* Warp to user mode. */
+	enter_new_process(argc, (userptr_t)(userAddr),(vaddr_t)(userAddr), entrypoint);
+
+	/* enter_new_process does not return. */
+	panic("enter_new_process returned\n");
+	return EINVAL;
+}
+/*
+ * Name
+waitpid - wait for a process to exit
+Library
+Standard C Library (libc, -lc)
+Synopsis
+#include <sys/wait.h>
+
+pid_t
+waitpid(pid_t pid, int *status, int options);
+Description
+Wait for the process specified by pid to exit, and return an encoded exit status in the integer pointed to by status. If that process has exited already, waitpid returns immediately. If that process does not exist, waitpid fails.
+
+What it means for a process to move from "has exited already" to "does not exist", and when this occurs, is something you must decide.
+
+If process P is "interested" in the exit code of process Q, process P should be able to find out that exit code by calling waitpid, even if Q exits somewhat before the time P calls waitpid. As described under _exit(), precisely what is meant by "interested" is up to you.
+
+You might implement restrictions or requirements on who may wait for which processes, like Unix does. You might also add a system call for one process to express interest in another process's exit code. If you do this, be sure to write a man page for the system call, and discuss the rationale for your choices therein in your design document.
+
+Note that in the absence of restrictions on who may wait for what, it is possible to set up situations that may result in deadlock. Your system must (of course) in some manner protect itself from these situations, either by prohibiting them or by detecting and resolving them.
+
+In order to make the userlevel code that ships with OS/161 work, assume that a parent process is always interested in the exit codes of its child processes generated with fork(), unless it does something special to indicate otherwise.
+
+The options argument should be 0. You are not required to implement any options. (However, your system should check to make sure that options you do not support are not requested.)
+
+If you desire, you may implement the Unix option WNOHANG; this causes waitpid, when called for a process that has not yet exited, to return 0 immediately instead of waiting.
+
+The Unix option WUNTRACED, to ask for reporting of processes that stop as well as exit, is also defined in the header files, but implementing this feature is not required or necessary unless you are implementing job control.
+
+You may also make up your own options if you find them helpful. However, please, document anything you make up.
+
+The encoding of the exit status is comparable to Unix and is defined by the flags found in <kern/wait.h>. (Userlevel code should include <sys/wait.h> to get these definitions.) A process can exit by calling _exit() or it can exit by receiving a fatal signal. In the former case the _MKWAIT_EXIT() macro should be used with the user-supplied exit code to prepare the exit status; in the latter, the _MKWAIT_SIG() macro (or _MKWAIT_CORE() if a core file was generated) should be used with the signal number. The result encoding also allows notification of processes that have stopped; this would be used in connection with job control and with ptrace-based debugging if you were to implement those things.
+
+To read the wait status, use the macros WIFEXITED(), WIFSIGNALED(), and/or WIFSTOPPED() to find out what happened, and then WEXITSTATUS(), WTERMSIG(), or WSTOPSIG() respectively to get the exit code or signal number. If WIFSIGNALED() is true, WCOREDUMP() can be used to check if a core file was generated. This is the same as Unix, although the value encoding is different from the historic Unix format.
+
+Return Values
+waitpid returns the process id whose exit status is reported in status. In OS/161, this is always the value of pid.
+
+If you implement WNOHANG, and WNOHANG is given, and the process specified by pid has not yet exited, waitpid returns 0.
+
+(In Unix, but not by default OS/161, you can wait for any of several processes by passing magic values of pid, so this return value can actually be useful.)
+
+On error, -1 is returned, and errno is set to a suitable error code for the error condition encountered.
+Errors
+The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
+
+
+    EINVAL		The options argument requested invalid or unsupported options.
+    ECHILD		The pid argument named a process that the current process was not interested in or that has not yet exited.
+    ESRCH		The pid argument named a nonexistent process.
+    EFAULT		The status argument was an invalid pointer.
+ */
+int sys_waitpid(pid_t pid, userptr_t status, int options, int *retval, int iskernspace)
+{
+	if(options!=0)
+		return EINVAL;
+
+	//if waitOnThread==NULL or exitSemaphore[i]==NULL(Thread exited or does not exist)
+	//then exitCode[i]==-1 thread does not exist or exit code collected
+	//else thread existed, exited and its exit code yet to be collected
+	//oderwise thread currently active. Do a P() on exitSemaphone[i].
+	//on V(), check exitCode[i], if it is nt -1 then return it and set it to -1
+	//else error
+
+	//As described under _exit(), precisely what is meant by "interested" is up to you...Decide on this
+	//TO allow only parents to wait on child, check if current threads Pid is PPID of the child thread. But this wont work with already exited thread.
+	//Status yet to understand
+	int exit = 0;
+	if(iskernspace == 0)//copysomevalue to check if its valid
+	{
+		int err = copyout(&exit, status, sizeof(int));
+		if(err)
+			return err;
+	}
+
+
+	if(pid<PID_MIN || pid > PID_MAX)
+		return ESRCH;
+	if(g_pidlist[pid]==NULL){
+		//The pid argument named a nonexistent process.
+		return ESRCH;
+	}
+	//Child Thread is still executing. Do a P() on the corresponding Semaphore.P will return immediately for a Zombie thread.
+	//We will allow only parent to collect exitcode of child. This defines what "Interested" means and will also ensure that there is no deadlock
+	struct thread* waitOnThread=g_pidlist[pid]->thread;
+
+	//TODO: need to add PPID to pidentry struct only parent should be able to collect
+	if(waitOnThread!=NULL && curthread->pid!=waitOnThread->ppid)
+		return ECHILD;
+	P(g_pidlist[pid]->sem);
+
+	exit = _MKWAIT_EXIT(g_pidlist[pid]->exitstatus);
+		if(iskernspace == 1)
+		{
+			*((int*)status) = g_pidlist[pid]->exitstatus;
+		}
+		else
+		{
+			int err = copyout(&exit, status, sizeof(int));
+			if(err)
+				return err;
+		}
+
+	sem_destroy(g_pidlist[pid]->sem);
+	kfree(g_pidlist[pid]);
+	g_pidlist[pid]=NULL;
+	*retval=pid;
+	return 0;
+
+}
+
+/*
+ * Name
+_exit - terminate process
+Library
+Standard C Library (libc, -lc)
+Synopsis
+#include <unistd.h>
+
+void
+_exit(int exitcode);
+Description
+Cause the current process to exit. The exit code exitcode is reported back to other process(es) via the waitpid() call. The process id of the exiting process should not be reused until all processes interested in collecting the exit code with waitpid have done so. (What "interested" means is intentionally left vague; you should design this.)
+Return Values
+_exit does not return.
+ */
+
+void sys_exit(int exitcode)
+{
+	int pid=curthread->pid;
+	g_pidlist[pid]->exitstatus=exitcode;//_MKWAIT_EXIT(exitcode);
+	g_pidlist[pid]->thread = NULL;
+	V(g_pidlist[pid]->sem);
+	thread_exit();
+}
+
+
+void child_fork(void* data1, unsigned long data2)
+{
+	struct message *msg = (struct message *) data1;
+	struct trapframe* ptf = msg->tf;
+	struct addrspace* as = msg->as;
+	(void)data2;
+	curthread->t_addrspace = as;
+	as_activate(curthread->t_addrspace);
+
+	*(msg->pid) = curthread->pid;
+	struct trapframe tf;
+	clonetrapframe(ptf, &tf);
+
+	tf.tf_a3 = 0;
+	tf.tf_v0 = 0;
+	tf.tf_epc += 4;
+
+	//kfree(ptf);
+
+	V(msg->sem);
+
+
+	mips_usermode(&tf);
+
+}
+
+int createpid(struct thread* newthread, pid_t *ret)
+{
+	pid_t i;
+	lock_acquire(g_lk_pid);
+	for(i=3; i<PID_MAX; i++)
+		if(g_pidlist[i] == NULL)
+		{
+			struct pidentry *pident = kmalloc(sizeof(struct pidentry));
+			pident->exitstatus = 0;
+			pident->thread = newthread;
+			pident->sem = sem_create("threadsem", 0);
+			g_pidlist[i]= pident;
+			*ret = i;
+			lock_release(g_lk_pid);
+			return 0;
+		}
+	lock_release(g_lk_pid);
+	return ENPROC;
+}
diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
index a6f45c8..9fd3e7b 100644
--- a/kern/syscall/runprogram.c
+++ b/kern/syscall/runprogram.c
@@ -44,6 +44,19 @@
 #include <vfs.h>
 #include <syscall.h>
 #include <test.h>
+#include <copyinout.h>
+
+int kstrcpy(char* src, char* dest)
+{
+	int i=0;
+	while(src[i] != '\0')
+	{
+		dest[i] = src[i];
+		i++;
+	}
+	dest[i++]= '\0';
+	return i;
+}
 
 /*
  * Load program "progname" and start running it in usermode.
@@ -52,12 +65,53 @@
  * Calls vfs_open on progname and thus may destroy it.
  */
 int
-runprogram(char *progname)
+runprogram(char *progname,char** args, unsigned long nargs)
 {
 	struct vnode *v;
 	vaddr_t entrypoint, stackptr;
 	int result;
 
+	//Copy the arguments into kernel buffer
+	unsigned long j=0;
+	size_t strlen=0;
+	int size=0;
+	unsigned long argc;
+	//Calculate the size of the array to allocate
+	char * tempArgs=kmalloc(1000);
+
+	while(j< nargs){
+		strlen = kstrcpy(args[j], tempArgs);//copyinstr((userptr_t)(args[j]), tempArgs, 1000,&strlen);
+		strlen=strlen + 4 - strlen%4;
+		size+=strlen;
+		j++;
+	}
+	argc=j;
+	//Add space for 4 integers
+	size+=argc*4;
+	size+=4;//for Null
+
+	char * kargv= kmalloc(size);
+	int top=argc*4+4;
+	j=0;
+	while(j< nargs){
+		strlen=0;
+		*((int*)(kargv + j*4))=top;
+		strlen = kstrcpy(args[j], kargv+top);//copyinstr((userptr_t)args[j], kargv+top, 1000,&strlen);
+		top+=strlen;
+		while(top%4!=0){
+			*(kargv+top)='\0';
+			top++;
+		}
+		j++;
+	}
+	int * ka = (int*)(kargv + j*4);
+	*(ka)=0;
+
+	//kargv is constructed
+
+
+
+
 	/* Open the file. */
 	result = vfs_open(progname, O_RDONLY, 0, &v);
 	if (result) {
@@ -95,12 +149,118 @@ runprogram(char *progname)
 		return result;
 	}
 
+
+
+	//Initializing STD IN
+	struct vnode *std;
+	char con[5] = "con:";
+	int err = vfs_open(con, O_RDONLY, 0x660, &std);
+	if(err)
+		KASSERT("Initializing STDIN failed");
+	struct filehandle *fh = kmalloc(sizeof(struct filehandle));
+	if(fh==NULL)
+		KASSERT("Memory allocation for file handle failed");
+	fh->fileobject = std;
+	fh->offset = 0;
+	fh->open_mode = O_RDONLY;
+	fh->lk_fileaccess = lock_create("filelock");
+	fh->refcount = 0;
+
+	// *fd = addtofiletable(fh);	we'll set fd once we implement filetable;
+	curthread->filetable[0] = fh;
+
+	//Initializing STDOUT
+	err = vfs_open(con, O_WRONLY, 0x660, &std);
+	if(err)
+		KASSERT("Initializing STDOUT failed");
+	fh = kmalloc(sizeof(struct filehandle));
+	if(fh==NULL)
+		KASSERT("Memory allocation for file handle failed");
+	fh->fileobject = std;
+	fh->offset = 0;
+	fh->open_mode = O_WRONLY;
+	fh->lk_fileaccess = lock_create("filelock");
+	fh->refcount = 0;
+
+
+	// *fd = addtofiletable(fh);	we'll set fd once we implement filetable;
+	curthread->filetable[1] = fh;
+
+	//Initializing STDERR
+	err = vfs_open(con, O_WRONLY, 0660, &std);
+	if(err)
+		KASSERT("Initializing STDERR failed");
+	fh = kmalloc(sizeof(struct filehandle));
+	if(fh==NULL)
+		panic("Memory allocation for file handle failed");
+	fh->fileobject = std;
+	fh->offset = 0;
+	fh->open_mode = O_WRONLY;
+	fh->lk_fileaccess = lock_create("filelock");
+	fh->refcount = 0;
+
+
+	// *fd = addtofiletable(fh);	we'll set fd once we implement filetable;
+	curthread->filetable[2] = fh;
+
+	//initialize filetable to NULL except for STDIO
+	int i;
+	for(i=3; i < OPEN_MAX;i++)
+		curthread->filetable[i] = NULL;
+
+
+
+	//	lock_acquire(&g_lk_pid);
+	for(i=3; i<PID_MAX; i++)
+	{
+		g_pidlist[i]= NULL;
+	}
+	//	lock_release(&g_lk_pid);
+
+	//let us assume this is the init process/thread set the pid to 1
+	curthread->pid = PID_MIN;
+	curthread->ppid = 0;
+	struct pidentry* pident = kmalloc(sizeof(struct pidentry));
+	pident->exitstatus = 0;
+	pident->thread = curthread;
+	pident->sem = sem_create("threadsem", 0);
+	g_pidlist[PID_MIN] = pident;
+
+	V(g_runprogsem);
+
+
+
+
+	//Copy the arguments to userstack
+	j=0;
+	int * userAddr=(int *)(stackptr-size);
+
+	while(j<argc){
+		ka = (int*)(kargv + j*4);
+		*ka=*ka+(int)userAddr;
+		//userAddr+=2;
+		j++;
+	}
+	copyout(kargv, (userptr_t)userAddr, (size_t)size);
+	//Copied to user space
+
+	char* copyinstack = kmalloc(size);
+	copyin((userptr_t)userAddr,(void *)copyinstack,(size_t)size);
+
+	int k=0;
+	for(k=0;k<size;k++)
+	{
+		kprintf("%c", copyinstack[i]);
+	}
+	//while(1);
+	/* Warp to user mode. */
+	enter_new_process(argc, (userptr_t)(userAddr),(vaddr_t)(userAddr), entrypoint);
+
 	/* Warp to user mode. */
-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
-			  stackptr, entrypoint);
-	
+	//	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+	//			stackptr, entrypoint);
+
 	/* enter_new_process does not return. */
 	panic("enter_new_process returned\n");
 	return EINVAL;
 }
-
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 9a7468c..651a2ab 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -47,20 +47,20 @@
 struct semaphore *
 sem_create(const char *name, int initial_count)
 {
-        struct semaphore *sem;
+	struct semaphore *sem;
 
-        KASSERT(initial_count >= 0);
+	KASSERT(initial_count >= 0);
 
-        sem = kmalloc(sizeof(struct semaphore));
-        if (sem == NULL) {
-                return NULL;
-        }
+	sem = kmalloc(sizeof(struct semaphore));
+	if (sem == NULL) {
+		return NULL;
+	}
 
-        sem->sem_name = kstrdup(name);
-        if (sem->sem_name == NULL) {
-                kfree(sem);
-                return NULL;
-        }
+	sem->sem_name = kstrdup(name);
+	if (sem->sem_name == NULL) {
+		kfree(sem);
+		return NULL;
+	}
 
 	sem->sem_wchan = wchan_create(sem->sem_name);
 	if (sem->sem_wchan == NULL) {
@@ -70,38 +70,38 @@ sem_create(const char *name, int initial_count)
 	}
 
 	spinlock_init(&sem->sem_lock);
-        sem->sem_count = initial_count;
+	sem->sem_count = initial_count;
 
-        return sem;
+	return sem;
 }
 
 void
 sem_destroy(struct semaphore *sem)
 {
-        KASSERT(sem != NULL);
+	KASSERT(sem != NULL);
 
 	/* wchan_cleanup will assert if anyone's waiting on it */
 	spinlock_cleanup(&sem->sem_lock);
 	wchan_destroy(sem->sem_wchan);
-        kfree(sem->sem_name);
-        kfree(sem);
+	kfree(sem->sem_name);
+	kfree(sem);
 }
 
 void 
 P(struct semaphore *sem)
 {
-        KASSERT(sem != NULL);
+	KASSERT(sem != NULL);
 
-        /*
-         * May not block in an interrupt handler.
-         *
-         * For robustness, always check, even if we can actually
-         * complete the P without blocking.
-         */
-        KASSERT(curthread->t_in_interrupt == false);
+	/*
+	 * May not block in an interrupt handler.
+	 *
+	 * For robustness, always check, even if we can actually
+	 * complete the P without blocking.
+	 */
+	KASSERT(curthread->t_in_interrupt == false);
 
 	spinlock_acquire(&sem->sem_lock);
-        while (sem->sem_count == 0) {
+	while (sem->sem_count == 0) {
 		/*
 		 * Bridge to the wchan lock, so if someone else comes
 		 * along in V right this instant the wakeup can't go
@@ -120,24 +120,24 @@ P(struct semaphore *sem)
 		 */
 		wchan_lock(sem->sem_wchan);
 		spinlock_release(&sem->sem_lock);
-                wchan_sleep(sem->sem_wchan);
+		wchan_sleep(sem->sem_wchan);
 
 		spinlock_acquire(&sem->sem_lock);
-        }
-        KASSERT(sem->sem_count > 0);
-        sem->sem_count--;
+	}
+	KASSERT(sem->sem_count > 0);
+	sem->sem_count--;
 	spinlock_release(&sem->sem_lock);
 }
 
 void
 V(struct semaphore *sem)
 {
-        KASSERT(sem != NULL);
+	KASSERT(sem != NULL);
 
 	spinlock_acquire(&sem->sem_lock);
 
-        sem->sem_count++;
-        KASSERT(sem->sem_count > 0);
+	sem->sem_count++;
+	KASSERT(sem->sem_count > 0);
 	wchan_wakeone(sem->sem_wchan);
 
 	spinlock_release(&sem->sem_lock);
@@ -150,59 +150,98 @@ V(struct semaphore *sem)
 struct lock *
 lock_create(const char *name)
 {
-        struct lock *lock;
-
-        lock = kmalloc(sizeof(struct lock));
-        if (lock == NULL) {
-                return NULL;
-        }
-
-        lock->lk_name = kstrdup(name);
-        if (lock->lk_name == NULL) {
-                kfree(lock);
-                return NULL;
-        }
-        
-        // add stuff here as needed
-        
-        return lock;
+	struct lock *lock;
+
+	lock = kmalloc(sizeof(struct lock));
+	if (lock == NULL) {
+		return NULL;
+	}
+
+	lock->lk_name = kstrdup(name);
+	if (lock->lk_name == NULL) {
+		kfree(lock);
+		return NULL;
+	}
+
+	lock->lk_wchan = wchan_create(lock->lk_name);
+	if (lock->lk_wchan == NULL) {
+		kfree(lock->lk_name);
+		kfree(lock);
+		return NULL;
+	}
+
+	spinlock_init(&lock->lk_lock);
+	lock->lk_held = false;
+
+	return lock;
 }
 
 void
 lock_destroy(struct lock *lock)
 {
-        KASSERT(lock != NULL);
+	KASSERT(lock != NULL);
 
-        // add stuff here as needed
-        
-        kfree(lock->lk_name);
-        kfree(lock);
+
+	/* wchan_cleanup will assert if anyone's waiting on it */
+	spinlock_cleanup(&lock->lk_lock);
+	wchan_destroy(lock->lk_wchan);
+
+	kfree(lock->lk_name);
+	kfree(lock);
 }
 
 void
 lock_acquire(struct lock *lock)
 {
-        // Write this
-
-        (void)lock;  // suppress warning until code gets written
+	KASSERT(lock != NULL);
+
+	/*
+	 * May not block in an interrupt handler.
+	 *
+	 * For robustness, always check, even if we can actually
+	 * complete the acquire without blocking.
+	 */
+	KASSERT(curthread->t_in_interrupt == false);
+
+	spinlock_acquire(&lock->lk_lock);
+	while (lock->lk_held == true) {
+		wchan_lock(lock->lk_wchan);
+		spinlock_release(&lock->lk_lock);
+		wchan_sleep(lock->lk_wchan);
+
+		spinlock_acquire(&lock->lk_lock);
+	}
+	KASSERT(lock->lk_held == false);
+	lock->lk_held = true;
+	lock->lk_holder = curthread;
+	spinlock_release(&lock->lk_lock);
 }
 
 void
 lock_release(struct lock *lock)
 {
-        // Write this
-
-        (void)lock;  // suppress warning until code gets written
+	KASSERT(lock != NULL);
+	//    KASSERT(lock_do_i_hold(lock));
+	spinlock_acquire(&lock->lk_lock);
+
+	lock->lk_held = false;
+	KASSERT(lock->lk_held == false);
+	wchan_wakeone(lock->lk_wchan);
+	lock->lk_holder = NULL;
+	spinlock_release(&lock->lk_lock);
 }
 
 bool
 lock_do_i_hold(struct lock *lock)
 {
-        // Write this
+	KASSERT(lock != NULL);
+	bool returnValue = false;
+	spinlock_acquire(&lock->lk_lock);
 
-        (void)lock;  // suppress warning until code gets written
+	returnValue = lock->lk_held && (curthread == lock->lk_holder);
 
-        return true; // dummy until code gets written
+	spinlock_release(&lock->lk_lock);
+	return returnValue;
 }
 
 ////////////////////////////////////////////////////////////
@@ -213,55 +252,159 @@ lock_do_i_hold(struct lock *lock)
 struct cv *
 cv_create(const char *name)
 {
-        struct cv *cv;
-
-        cv = kmalloc(sizeof(struct cv));
-        if (cv == NULL) {
-                return NULL;
-        }
-
-        cv->cv_name = kstrdup(name);
-        if (cv->cv_name==NULL) {
-                kfree(cv);
-                return NULL;
-        }
-        
-        // add stuff here as needed
-        
-        return cv;
+	struct cv *cv;
+
+	cv = kmalloc(sizeof(struct cv));
+	if (cv == NULL) {
+		return NULL;
+	}
+
+	cv->cv_name = kstrdup(name);
+	if (cv->cv_name==NULL) {
+		kfree(cv);
+		return NULL;
+	}
+
+	// add stuff here as needed
+
+	cv->cv_wchan=wchan_create(cv->cv_name);
+	if (cv->cv_wchan == NULL) {
+		kfree(cv->cv_name);
+		kfree(cv);
+		return NULL;
+	}
+	return cv;
 }
 
 void
 cv_destroy(struct cv *cv)
 {
-        KASSERT(cv != NULL);
+	KASSERT(cv != NULL);
 
-        // add stuff here as needed
-        
-        kfree(cv->cv_name);
-        kfree(cv);
+	/* wchan_cleanup will assert if anyone's waiting on it */
+	wchan_destroy(cv->cv_wchan);
+	kfree(cv->cv_name);
+	kfree(cv);
 }
 
 void
 cv_wait(struct cv *cv, struct lock *lock)
 {
-        // Write this
-        (void)cv;    // suppress warning until code gets written
-        (void)lock;  // suppress warning until code gets written
+	// Write this
+	KASSERT(cv != NULL);
+	KASSERT(curthread->t_in_interrupt == false);
+	wchan_lock(cv->cv_wchan);
+	lock_release(lock);
+	wchan_sleep(cv->cv_wchan);
+	lock_acquire(lock);
 }
 
 void
 cv_signal(struct cv *cv, struct lock *lock)
 {
-        // Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	(void)lock;
+	KASSERT(cv != NULL);
+	//lock_acquire(lock);
+	wchan_wakeone(cv->cv_wchan);
+	//lock_release(lock);
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
+	(void)lock;
 	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+	KASSERT(cv != NULL);
+	//lock_acquire(lock);
+	wchan_wakeall(cv->cv_wchan);
+	//lock_release(lock);
+
+}
+
+struct rwlock * rwlock_create(const char *name)
+{
+	struct rwlock *rwlk;
+
+
+	rwlk = kmalloc(sizeof(struct rwlock));
+	if (rwlk == NULL) {
+		return NULL;
+	}
+
+	rwlk->rwlock_name = kstrdup(name);
+	if (rwlk->rwlock_name == NULL) {
+		kfree(rwlk);
+		return NULL;
+	}
+
+	rwlk->writelock = lock_create(name);
+	if (rwlk->writelock == NULL) {
+		kfree(rwlk->rwlock_name);
+		kfree(rwlk);
+
+		return NULL;
+	}
+
+	rwlk->transactionlock = lock_create(name);
+	if (rwlk->transactionlock == NULL) {
+		kfree(rwlk->rwlock_name);
+		kfree(rwlk->writelock);
+		kfree(rwlk);
+		return NULL;
+	}
+
+	rwlk->cv_writer = cv_create(name);
+	if(rwlk->cv_writer == NULL)
+	{
+		kfree(rwlk->transactionlock);
+		kfree(rwlk->rwlock_name);
+		kfree(rwlk->writelock);
+		kfree(rwlk);
+		return NULL;
+	}
+	return rwlk;
+}
+void rwlock_destroy(struct rwlock *rwlk)
+{
+	kfree(rwlk->rwlock_name);
+	kfree(rwlk->writelock);
+	kfree(rwlk->transactionlock);
+	kfree(rwlk->cv_writer);
+	kfree(rwlk);
+}
+
+void rwlock_acquire_read(struct rwlock *rwlk)
+{
+	lock_acquire(rwlk->writelock);
+	lock_acquire(rwlk->transactionlock);
+	lock_release(rwlk->writelock);
+
+
+	rwlk->counter++;
+
+	lock_release(rwlk->transactionlock);
+}
+void rwlock_release_read(struct rwlock *rwlk)
+{
+	lock_acquire(rwlk->transactionlock);
+	rwlk->counter--;
+
+	if(rwlk->counter==0)
+		cv_signal(rwlk->cv_writer, rwlk->transactionlock);
+	lock_release(rwlk->transactionlock);
+}
+void rwlock_acquire_write(struct rwlock *rwlk)
+{
+	lock_acquire(rwlk->writelock);
+
+	lock_acquire(rwlk->transactionlock);
+
+	while(rwlk->counter != 0)
+		cv_wait(rwlk->cv_writer, rwlk->transactionlock);
+
+	lock_release(rwlk->transactionlock);
+}
+void rwlock_release_write(struct rwlock *rwlk)
+{
+	lock_release(rwlk->writelock);
 }
diff --git a/kern/thread/thread.c b/kern/thread/thread.c
index e7235e3..ad47a06 100644
--- a/kern/thread/thread.c
+++ b/kern/thread/thread.c
@@ -154,6 +154,9 @@ thread_create(const char *name)
 
 	/* If you add to struct thread, be sure to initialize here */
 
+	//Anand: Setting exitCode to -999(Default) and initializing semaphore
+	//thread->exitSemaphore=sem_create("exitSemaphore",1);
+
 	return thread;
 }
 
@@ -176,7 +179,7 @@ cpu_create(unsigned hardware_number)
 	if (c == NULL) {
 		panic("cpu_create: Out of memory\n");
 	}
-	
+
 	c->c_self = c;
 	c->c_hardware_number = hardware_number;
 
@@ -261,6 +264,9 @@ thread_destroy(struct thread *thread)
 
 	/* sheer paranoia */
 	thread->t_wchan_name = "DESTROYED";
+	//Anand: destroying exitSempahore
+	//sem_destroy(thread->exitSemaphore);
+
 
 	kfree(thread->t_name);
 	kfree(thread);
@@ -419,7 +425,7 @@ thread_start_cpus(void)
 
 	cpu_startup_sem = sem_create("cpu_hatch", 0);
 	mainbus_start_cpus();
-	
+
 	for (i=0; i<cpuarray_num(&allcpus) - 1; i++) {
 		P(cpu_startup_sem);
 	}
@@ -478,9 +484,9 @@ thread_make_runnable(struct thread *target, bool already_have_lock)
  */
 int
 thread_fork(const char *name,
-	    void (*entrypoint)(void *data1, unsigned long data2),
-	    void *data1, unsigned long data2,
-	    struct thread **ret)
+		void (*entrypoint)(void *data1, unsigned long data2),
+		void *data1, unsigned long data2,
+		struct thread **ret)
 {
 	struct thread *newthread;
 
@@ -523,6 +529,25 @@ thread_fork(const char *name,
 	/* Set up the switchframe so entrypoint() gets called */
 	switchframe_init(newthread, entrypoint, data1, data2);
 
+	int i;
+
+	//copy the filetable
+	for(i=0; i<OPEN_MAX; i++)
+	{
+		newthread->filetable[i] = curthread->filetable[i];
+		if(newthread->filetable[i]!=NULL && i>2)
+		{
+			newthread->filetable[i]->refcount++;
+		}
+	}
+
+	//assign pid and ppid
+	int newpid;
+	int err = createpid(newthread, &newpid);
+	if(err)
+		return err;
+	newthread->pid = newpid;
+	newthread->ppid = curthread->pid;
 	/* Lock the current cpu's run queue and make the new thread runnable */
 	thread_make_runnable(newthread, false);
 
@@ -587,13 +612,13 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
 
 	/* Put the thread in the right place. */
 	switch (newstate) {
-	    case S_RUN:
+	case S_RUN:
 		panic("Illegal S_RUN in thread_switch\n");
 		break;
-	    case S_READY:
+	case S_READY:
 		thread_make_runnable(cur, true /*have lock*/);
 		break;
-	    case S_SLEEP:
+	case S_SLEEP:
 		cur->t_wchan_name = wc->wc_name;
 		/*
 		 * Add the thread to the list in the wait channel, and
@@ -611,7 +636,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
 		threadlist_addtail(&wc->wc_threads, cur);
 		wchan_unlock(wc);
 		break;
-	    case S_ZOMBIE:
+	case S_ZOMBIE:
 		cur->t_wchan_name = "ZOMBIE";
 		threadlist_addtail(&curcpu->c_zombies, cur);
 		break;
@@ -736,7 +761,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
  */
 void
 thread_startup(void (*entrypoint)(void *data1, unsigned long data2),
-	       void *data1, unsigned long data2)
+		void *data1, unsigned long data2)
 {
 	struct thread *cur;
 
@@ -817,8 +842,9 @@ thread_exit(void)
 	/* Check the stack guard band. */
 	thread_checkstack(cur);
 
+
 	/* Interrupts off on this processor */
-        splhigh();
+	splhigh();
 	thread_switch(S_ZOMBIE, NULL);
 	panic("The zombie walks!\n");
 }
@@ -845,14 +871,14 @@ thread_yield(void)
 void
 schedule(void)
 {
-  // 28 Feb 2012 : GWA : Leave the default scheduler alone!
+	// 28 Feb 2012 : GWA : Leave the default scheduler alone!
 }
 #else
 void
 schedule(void)
 {
-  // 28 Feb 2012 : GWA : Implement your scheduler that prioritizes
-  // "interactive" threads here.
+	// 28 Feb 2012 : GWA : Implement your scheduler that prioritizes
+	// "interactive" threads here.
 }
 #endif
 
@@ -947,8 +973,8 @@ thread_consider_migration(void)
 			t->t_cpu = c;
 			threadlist_addtail(&c->c_runqueue, t);
 			DEBUG(DB_THREADS,
-			      "Migrated thread %s: cpu %u -> %u",
-			      t->t_name, curcpu->c_number, c->c_number);
+					"Migrated thread %s: cpu %u -> %u",
+					t->t_name, curcpu->c_number, c->c_number);
 			to_send--;
 			if (c->c_isidle) {
 				/*
@@ -1201,7 +1227,7 @@ interprocessor_interrupt(void)
 		spinlock_acquire(&curcpu->c_runqueue_lock);
 		if (!curcpu->c_isidle) {
 			kprintf("cpu%d: offline: warning: not idle\n",
-				curcpu->c_number);
+					curcpu->c_number);
 		}
 		spinlock_release(&curcpu->c_runqueue_lock);
 		kprintf("cpu%d: offline.\n", curcpu->c_number);
@@ -1228,3 +1254,5 @@ interprocessor_interrupt(void)
 	curcpu->c_ipi_pending = 0;
 	spinlock_release(&curcpu->c_ipi_lock);
 }
+
+
diff --git a/kern/vfs/vfspath.c b/kern/vfs/vfspath.c
index 3e439c6..2ae3507 100644
--- a/kern/vfs/vfspath.c
+++ b/kern/vfs/vfspath.c
@@ -249,6 +249,34 @@ vfs_symlink(const char *contents, char *path)
 	return result;
 }
 
+int vfs_read(struct vnode *vn, struct uio *uio)
+{
+		int result;
+		result = VOP_READ(vn, uio);
+
+//		VOP_DECREF(vn);
+
+		return result;
+}
+
+int vfs_write(struct vnode *vn, struct uio *uio)
+{
+		int result;
+		result = VOP_WRITE(vn, uio);
+
+		//VOP_DECREF(vn);
+
+		return result;
+}
+
+off_t vfs_lseek(struct vnode *vn, off_t pos)
+{
+	int result;
+	result = VOP_TRYSEEK(vn, pos);
+
+	return result;
+}
+
 /*
  * Does most of the work for readlink().
  *
diff --git a/kern/vm/kmalloc.c b/kern/vm/kmalloc.c
index 09b764b..ea6438d 100644
--- a/kern/vm/kmalloc.c
+++ b/kern/vm/kmalloc.c
@@ -439,6 +439,8 @@ subpage_kmalloc(size_t sz)
 				pr->freelist_offset = fla - prpage;
 			}
 			else {
+				if(pr->nfree != 0)
+					panic("help");
 				KASSERT(pr->nfree == 0);
 				pr->freelist_offset = INVALID_OFFSET;
 			}
diff --git a/submit.patch b/submit.patch
new file mode 100644
index 0000000..20d5bcd
--- /dev/null
+++ b/submit.patch
@@ -0,0 +1,2549 @@
+diff --git a/kern/arch/mips/include/trapframe.h b/kern/arch/mips/include/trapframe.h
+index 993b10c..c3c63dd 100644
+--- a/kern/arch/mips/include/trapframe.h
++++ b/kern/arch/mips/include/trapframe.h
+@@ -77,6 +77,8 @@ struct trapframe {
+ 	uint32_t tf_epc;	/* coprocessor 0 epc register */
+ };
+ 
++void clonetrapframe(struct trapframe *, struct trapframe*);
++
+ /*
+  * MIPS exception codes.
+  */
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..70b882e 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -35,6 +35,7 @@
+ #include <thread.h>
+ #include <current.h>
+ #include <syscall.h>
++#include <copyinout.h>
+ 
+ 
+ /*
+@@ -96,22 +97,99 @@ syscall(struct trapframe *tf)
+ 	 * deal with it except for calls that return other values, 
+ 	 * like write.
+ 	 */
+-
++	int32_t pid;
+ 	retval = 0;
++	int32_t offsethigh, offsetlow;	//offsethigh is the most significant 32bits, offsetlow is the least.
++	off_t pos;
+ 
+ 	switch (callno) {
+-	    case SYS_reboot:
++	case SYS_reboot:
+ 		err = sys_reboot(tf->tf_a0);
+ 		break;
+ 
+-	    case SYS___time:
++	case SYS___time:
+ 		err = sys___time((userptr_t)tf->tf_a0,
+-				 (userptr_t)tf->tf_a1);
++				(userptr_t)tf->tf_a1);
++		break;
++
++		/******************************FILE SYSTEM CALLS**************************************/
++	case SYS_open:
++		err = sys_open((userptr_t)tf->tf_a0, tf->tf_a1, &retval);
++		break;
++
++	case SYS_read:
++		err = sys_read(tf->tf_a0, (userptr_t) tf->tf_a1 , tf->tf_a2, &retval/*bytesread*/ );
++		break;
++
++	case SYS_write:
++		err = sys_write(tf->tf_a0, (userptr_t) tf->tf_a1 , tf->tf_a2, &retval/* byteswritten*/);
++		break;
++
++	case SYS_lseek:
++		//TBD
++		pos = tf->tf_a2;	//assuming here that a2 contains the MS 32 bits. NEED TO VERIFY
++		pos = pos << 32;
++		pos = pos | tf->tf_a3;
++		//TBD;
++
++		err = sys_lseek(tf->tf_a0, pos, tf->tf_sp, &offsethigh, &offsetlow);
++
++		if(err==0)
++		{
++			retval = offsethigh;
++			tf->tf_v1 = offsetlow;
++		}
++
++		break;
++
++	case SYS_close:
++		err = sys_close(tf->tf_a0);
+ 		break;
+ 
+-	    /* Add stuff here */
+- 
+-	    default:
++	case SYS_dup2:
++		//DINT UNDERSTAND THE MAN SPECS NEED TO CLARIFY
++		err = sys_dup2(tf->tf_a0, tf->tf_a1,&retval);
++
++		break;
++
++	case SYS_chdir:
++		err = sys_chdir((userptr_t) tf->tf_a0);
++		break;
++
++	case SYS___getcwd:
++		err = sys___getcwd((userptr_t )tf->tf_a0, tf->tf_a1, &retval);
++		break;
++
++		/*****************************************END FILE SYSTEM CALLS**************************************/
++
++		/**************************************** START OF PROCESS SYSTEM CALLS ***************************/
++	case SYS_getpid:
++		pid = sys_getpid();
++		retval = (int32_t)pid;
++		err = 0;
++		break;
++
++	case SYS_fork:
++		err = sys_fork(tf, &retval);
++		break;
++	case SYS_waitpid:
++		err = sys_waitpid(tf->tf_a0,(userptr_t)tf->tf_a1,tf->tf_a2,&retval,0);
++		//copyout(&status,(userptr_t)tf->tf_a1,sizeof(int));
++		break;
++	case SYS__exit:
++		sys_exit(tf->tf_a0);
++		break;
++	case SYS_execv:
++		err=sys_execv((userptr_t)tf->tf_a0,(userptr_t)tf->tf_a1);
++		break;
++
++
++
++		/*****************************************END OF PROCESS SYSTEM CALLS******************/
++
++		/* Add stuff here */
++
++	default:
+ 		kprintf("Unknown syscall %d\n", callno);
+ 		err = ENOSYS;
+ 		break;
+@@ -132,12 +210,12 @@ syscall(struct trapframe *tf)
+ 		tf->tf_v0 = retval;
+ 		tf->tf_a3 = 0;      /* signal no error */
+ 	}
+-	
++
+ 	/*
+ 	 * Now, advance the program counter, to avoid restarting
+ 	 * the syscall over and over again.
+ 	 */
+-	
++
+ 	tf->tf_epc += 4;
+ 
+ 	/* Make sure the syscall code didn't forget to lower spl */
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..451173d 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,8 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file      syscall/file_syscalls.c
++file	  syscall/proc_syscalls.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..48e2d18 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -74,8 +74,10 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
+-        // add what you need here
+-        // (don't forget to mark things volatile as needed)
++    	struct wchan *lk_wchan;
++    	struct spinlock lk_lock;
++        volatile bool lk_held;
++        volatile struct thread *lk_holder;
+ };
+ 
+ struct lock *lock_create(const char *name);
+@@ -113,7 +115,8 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
+-        // add what you need here
++        struct wchan *cv_wchan;
++         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+ 
+@@ -143,6 +146,10 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ 
+ struct rwlock {
+         char *rwlock_name;
++        volatile int counter;
++        struct lock *writelock;
++        struct lock *transactionlock;
++        struct cv *cv_writer;
+ };
+ 
+ struct rwlock * rwlock_create(const char *);
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..7cab4e4 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -58,4 +58,23 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
+ int sys_reboot(int code);
+ int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
+ 
++//ASST2 File operation prototypes
++int sys_open(userptr_t filename, int flags, int32_t *fd, ...);
++int sys_read(int fd, userptr_t buf, size_t buflen, int32_t *bytesread);
++int sys_write(int fd, userptr_t buf, size_t nbytes, int32_t *byteswritten);
++int sys_lseek(int fd, off_t pos, int whence, int32_t *offsethigh, int32_t *offsetlow);
++int sys_close(int fd);
++int sys_dup2(int oldfd, int newfd, int *);
++int sys_chdir(userptr_t pathname);
++int sys___getcwd(userptr_t buf, size_t buflen, int32_t *ret);
++
++//ASST2 Process syscalls
++pid_t sys_getpid(void);
++int sys_fork(struct trapframe *ptf, pid_t *pid);
++int sys_execv(userptr_t program, userptr_t args);
++int sys_waitpid(pid_t pid, userptr_t status, int options,int*, int);
++void sys_exit(int exitcode);
++
++void child_fork(void* data1, unsigned long data2);
++
+ #endif /* _SYSCALL_H_ */
+diff --git a/kern/include/test.h b/kern/include/test.h
+index 240d583..c0c72d2 100644
+--- a/kern/include/test.h
++++ b/kern/include/test.h
+@@ -66,7 +66,6 @@ void whalemating_cleanup(void);
+ void inQuadrant(int);
+ void leaveIntersection(void);
+ int stoplight(int, char **);
+-
+ void gostraight(void *, unsigned long);
+ void turnleft(void *, unsigned long);
+ void turnright(void *, unsigned long);
+@@ -105,8 +104,8 @@ int mallocstress(int, char **);
+ int nettest(int, char **);
+ 
+ /* Routine for running a user-level program. */
+-int runprogram(char *progname);
+-
++int runprogram(char *progname,char**, unsigned long);
++int kstrcpy(char* src, char* dest);
+ /* Kernel menu system. */
+ void menu(char *argstr);
+ 
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..05f5f0f 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -38,6 +38,8 @@
+ 
+ #include <spinlock.h>
+ #include <threadlist.h>
++#include <limits.h>
++#include <synch.h>
+ 
+ struct addrspace;
+ struct cpu;
+@@ -100,6 +102,10 @@ struct thread {
+ 	bool t_in_interrupt;		/* Are we in an interrupt? */
+ 	int t_curspl;			/* Current spl*() state */
+ 	int t_iplhigh_count;		/* # of times IPL has been raised */
++	pid_t pid;
++	pid_t ppid;
++	//Anand: Added for waitpid implementation
++	//struct semaphore* exitSemaphore;
+ 
+ 	/*
+ 	 * Public fields
+@@ -112,8 +118,36 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++	//TODO :need to set this to NULL somewhere
++	struct filehandle* filetable[OPEN_MAX];	// remember that 0, 1 and 2 are taken
+ };
+ 
++//Move this out of here later
++struct filehandle
++{
++	int open_mode;
++	off_t offset;
++	struct vnode *fileobject;
++	struct lock* lk_fileaccess;
++	int refcount;
++};
++
++struct pidentry
++{
++	struct thread* thread;
++	struct semaphore *sem;
++	int exitstatus;
++};
++
++int createfd(struct thread* thread);
++
++struct pidentry* g_pidlist[PID_MAX];
++//int exitStatusCode[PID_MAX];
++
++struct lock* g_lk_pid;
++int createpid(struct thread* newthread, pid_t *ret);
++
++struct semaphore *g_runprogsem;
+ /* Call once during system startup to allocate data structures. */
+ void thread_bootstrap(void);
+ 
+diff --git a/kern/include/uio.h b/kern/include/uio.h
+index 5d97c48..761cad7 100644
+--- a/kern/include/uio.h
++++ b/kern/include/uio.h
+@@ -119,5 +119,8 @@ int uiomovezeros(size_t len, struct uio *uio);
+ void uio_kinit(struct iovec *, struct uio *,
+ 	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+ 
++void uio_uinit(struct iovec *, struct uio *,
++	       void *kbuf, size_t len, off_t pos, enum uio_rw rw);
++
+ 
+ #endif /* _UIO_H_ */
+diff --git a/kern/include/vfs.h b/kern/include/vfs.h
+index 42f37a5..48fe403 100644
+--- a/kern/include/vfs.h
++++ b/kern/include/vfs.h
+@@ -114,6 +114,10 @@ int vfs_rename(char *oldpath, char *newpath);
+ int vfs_chdir(char *path);
+ int vfs_getcwd(struct uio *buf);
+ 
++
++int vfs_read(struct vnode *vn, struct uio *uio);
++int vfs_write(struct vnode *vn, struct uio *uio);
++off_t vfs_lseek(struct vnode *vn, off_t pos);
+ /*
+  * Misc
+  *
+diff --git a/kern/lib/uio.c b/kern/lib/uio.c
+index 594fe96..40d1af5 100644
+--- a/kern/lib/uio.c
++++ b/kern/lib/uio.c
+@@ -163,3 +163,23 @@ uio_kinit(struct iovec *iov, struct uio *u,
+ 	u->uio_rw = rw;
+ 	u->uio_space = NULL;
+ }
++
++/*
++ * Convenience function to initialize an iovec and uio for kernel I/O.
++ */
++
++void
++uio_uinit(struct iovec *iov, struct uio *u,
++	  void *kbuf, size_t len, off_t pos, enum uio_rw rw)
++{
++	iov->iov_ubase = kbuf;
++	iov->iov_len = len;
++	u->uio_iov = iov;
++	u->uio_iovcnt = 1;
++	u->uio_offset = pos;
++	u->uio_resid = len;
++	u->uio_segflg = UIO_USERSPACE;
++	u->uio_rw = rw;
++	u->uio_space = NULL;
++	u->uio_space = curthread->t_addrspace;
++}
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..1ebfa47 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -100,7 +100,7 @@ boot(void)
+ 	kprintf("%s", harvard_copyright);
+ 	kprintf("\n");
+ 
+-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++	kprintf("anandpra@buffalo.edu's system version %s (%s #%d)\n", 
+ 		GROUP_VERSION, buildconfig, buildversion);
+ 	kprintf("\n");
+ 
+@@ -126,7 +126,7 @@ boot(void)
+ 
+ 	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
+ 	vfs_setbootfs("emu0");
+-
++	g_lk_pid=lock_create("createPIDLock");
+ 
+ 	/*
+ 	 * Make sure various things aren't screwed up.
+@@ -196,6 +196,8 @@ sys_reboot(int code)
+ 	return 0;
+ }
+ 
++
++
+ /*
+  * Kernel main. Boot up, then fork the menu thread; wait for a reboot
+  * request, and then shut down.
+diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+index 6c71551..9274d83 100644
+--- a/kern/startup/menu.c
++++ b/kern/startup/menu.c
+@@ -81,6 +81,8 @@ getinterval(time_t s1, uint32_t ns1, time_t s2, uint32_t ns2,
+  * It copies the program name because runprogram destroys the copy
+  * it gets by passing it to vfs_open(). 
+  */
++
++
+ static
+ void
+ cmd_progthread(void *ptr, unsigned long nargs)
+@@ -100,13 +102,15 @@ cmd_progthread(void *ptr, unsigned long nargs)
+ 
+ 	strcpy(progname, args[0]);
+ 
+-	result = runprogram(progname);
++	result = runprogram(progname,args, nargs);
+ 	if (result) {
+ 		kprintf("Running program %s failed: %s\n", args[0],
+ 			strerror(result));
+ 		return;
+ 	}
+ 
++	sys_exit(0);
++
+ 	/* NOTREACHED: runprogram only returns on error. */
+ }
+ 
+@@ -122,6 +126,9 @@ cmd_progthread(void *ptr, unsigned long nargs)
+  * array and strings, until you do this a race condition exists
+  * between that code and the menu input code.
+  */
++
++
++
+ static
+ int
+ common_prog(int nargs, char **args)
+@@ -132,16 +139,28 @@ common_prog(int nargs, char **args)
+ 	kprintf("Warning: this probably won't work with a "
+ 		"synchronization-problems kernel.\n");
+ #endif
++	g_runprogsem = sem_create("run prog sem",0);
+ 
++	struct thread *child = NULL;
+ 	result = thread_fork(args[0] /* thread name */,
+ 			cmd_progthread /* thread function */,
+ 			args /* thread arg */, nargs /* thread arg */,
+-			NULL);
++			&child);
+ 	if (result) {
+ 		kprintf("thread_fork failed: %s\n", strerror(result));
+ 		return result;
+ 	}
+ 
++	P(g_runprogsem);
++	int *status = kmalloc(sizeof(int));
++	int pid;
++	result = sys_waitpid(2, (userptr_t)(&status),0, &pid, 1);
++	if (result) {
++			kprintf("wait on user thread failed: %s\n", strerror(result));
++			return result;
++	}
++	sem_destroy(g_runprogsem);
++
+ 	return 0;
+ }
+ 
+diff --git a/kern/synchprobs/drivers.c b/kern/synchprobs/drivers.c
+index 02e336f..a4ba023 100644
+--- a/kern/synchprobs/drivers.c
++++ b/kern/synchprobs/drivers.c
+@@ -86,15 +86,15 @@ int whalemating(int nargs, char **args) {
+ 
+ 			switch (i) {
+ 			case 0:
+-				snprintf(name, sizeof(name), "Male Whale Thread %d", (i * 3) + j);
++				snprintf(name, sizeof(name), "Male Whale Thread %d", (i * 10) + j);
+ 				err = thread_fork(name, male, whalematingMenuSemaphore, j, NULL);
+ 				break;
+ 			case 1:
+-				snprintf(name, sizeof(name), "Female Whale Thread %d", (i * 3) + j);
++				snprintf(name, sizeof(name), "Female Whale Thread %d", (i * 10) + j);
+ 				err = thread_fork(name, female, whalematingMenuSemaphore, j, NULL);
+ 				break;
+ 			case 2:
+-				snprintf(name, sizeof(name), "Matchmaker Whale Thread %d", (i * 3) + j);
++				snprintf(name, sizeof(name), "Matchmaker Whale Thread %d", (i * 10) + j);
+ 				err = thread_fork(name, matchmaker, whalematingMenuSemaphore, j, NULL);
+ 				break;
+ 			}
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..78082a2 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -47,63 +47,98 @@
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
+ 
++static void getquadrants(unsigned long, int *);
++
++struct cv *cvWaitingMales;
++struct cv *cvWaitingFemales;
++struct semaphore *semMale;
++struct semaphore *semFemale;
++struct lock *lkMale;
++struct lock *lkFemale;
++
++
+ void whalemating_init() {
+-  return;
++	cvWaitingMales = cv_create("waitingmales");
++	cvWaitingFemales = cv_create("waitingfemales");
++	semMale = sem_create("semMale",0);
++	semFemale = sem_create("semFemale",0);
++	lkMale = lock_create("lkMale");
++	lkFemale = lock_create("lkFemale");
++	return;
+ }
+ 
+ // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
+-  return;
++	sem_destroy(semMale);
++	sem_destroy(semFemale);
++	cv_destroy(cvWaitingMales);
++	cv_destroy(cvWaitingFemales);
++	lock_destroy(lkMale);
++	lock_destroy(lkFemale);
++	return;
+ }
+ 
+ void
+ male(void *p, unsigned long which)
+ {
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+-  (void)which;
+-  
+-  male_start();
+-	// Implement this function 
+-  male_end();
+-
+-  // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+-  // whalemating driver can return to the menu cleanly.
+-  V(whalematingMenuSemaphore);
+-  return;
++	(void)which;
++
++	male_start();
++	V(semMale);
++	lock_acquire(lkMale);
++	cv_wait(cvWaitingMales, lkMale);
++	lock_release(lkMale);
++	male_end();
++
++	// 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++	// whalemating driver can return to the menu cleanly.
++	V(whalematingMenuSemaphore);
++	return;
+ }
+ 
+ void
+ female(void *p, unsigned long which)
+ {
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+-  (void)which;
+-  
+-  female_start();
+-	// Implement this function 
+-  female_end();
+-  
+-  // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+-  // whalemating driver can return to the menu cleanly.
+-  V(whalematingMenuSemaphore);
+-  return;
++	(void)which;
++
++	female_start();
++	V(semFemale);
++	lock_acquire(lkFemale);
++	cv_wait(cvWaitingFemales, lkFemale);
++	lock_release(lkFemale);
++
++	female_end();
++
++	// 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++	// whalemating driver can return to the menu cleanly.
++	V(whalematingMenuSemaphore);
++	return;
+ }
+ 
+ void
+ matchmaker(void *p, unsigned long which)
+ {
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+-  (void)which;
+-  
+-  matchmaker_start();
+-	// Implement this function 
+-  matchmaker_end();
+-  
+-  // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+-  // whalemating driver can return to the menu cleanly.
+-  V(whalematingMenuSemaphore);
+-  return;
++	(void)which;
++
++	matchmaker_start();
++	P(semMale);
++	P(semFemale);
++	lock_acquire(lkMale);
++	lock_acquire(lkFemale);
++	cv_signal(cvWaitingMales,lkMale);
++
++	cv_signal(cvWaitingFemales,lkFemale);
++	matchmaker_end();
++
++	// 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++	// whalemating driver can return to the menu cleanly.
++	V(whalematingMenuSemaphore);
++	return;
+ }
+ 
+ /*
+@@ -137,49 +172,106 @@ matchmaker(void *p, unsigned long which)
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
+ 
++struct lock *lkPlanning;
++struct lock *lkQuadrant[4];
++
+ void stoplight_init() {
+-  return;
++	lkQuadrant[0] = lock_create("lkZero");
++	lkQuadrant[1] = lock_create("lkOne");
++	lkQuadrant[2] = lock_create("lkTwo");
++	lkQuadrant[3] = lock_create("lkThree");
++	lkPlanning = lock_create("lkPlanning");
++	return;
+ }
+ 
+ // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
+-  return;
++	lock_destroy(lkQuadrant[0]);
++	lock_destroy(lkQuadrant[1]);
++	lock_destroy(lkQuadrant[2]);
++	lock_destroy(lkQuadrant[3]);
++	lock_destroy(lkPlanning);
++	return;
++}
++
++void getquadrants(unsigned long direction, int* ret)
++{
++	ret[0] = direction;
++	ret[1] = (direction + 3) % 4;
++	ret[2] = (direction  + 2) % 4;
++
+ }
+ 
+ void
+ gostraight(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
+-  
+-  // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+-  // stoplight driver can return to the menu cleanly.
+-  V(stoplightMenuSemaphore);
+-  return;
++
++	int quad[3];
++	getquadrants(direction, quad);
++
++	lock_acquire(lkPlanning);
++
++	lock_acquire(lkQuadrant[quad[0]]);
++	lock_acquire(lkQuadrant[quad[1]]);
++
++	lock_release(lkPlanning);
++	inQuadrant(quad[0]);
++	inQuadrant(quad[1]);
++	lock_release(lkQuadrant[quad[0]]);
++	leaveIntersection();
++	lock_release(lkQuadrant[quad[1]]);
++	// 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++	// stoplight driver can return to the menu cleanly.
++	V(stoplightMenuSemaphore);
++	return;
+ }
+ 
+ void
+ turnleft(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
+-  
+-  // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+-  // stoplight driver can return to the menu cleanly.
+-  V(stoplightMenuSemaphore);
+-  return;
++	int quad[3];
++	getquadrants(direction, quad);
++
++	lock_acquire(lkPlanning);
++
++	lock_acquire(lkQuadrant[quad[0]]);
++	lock_acquire(lkQuadrant[quad[1]]);
++	lock_acquire(lkQuadrant[quad[2]]);
++
++	lock_release(lkPlanning);
++	inQuadrant(quad[0]);
++	inQuadrant(quad[1]);
++	lock_release(lkQuadrant[quad[0]]);
++	inQuadrant(quad[2]);
++	lock_release(lkQuadrant[quad[1]]);
++	leaveIntersection();
++	lock_release(lkQuadrant[quad[2]]);
++
++	// 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++	// stoplight driver can return to the menu cleanly.
++	V(stoplightMenuSemaphore);
++	return;
+ }
+ 
+ void
+ turnright(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+-  (void)direction;
+ 
+-  // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+-  // stoplight driver can return to the menu cleanly.
+-  V(stoplightMenuSemaphore);
+-  return;
++	lock_acquire(lkPlanning);
++
++	lock_acquire(lkQuadrant[direction]);
++	inQuadrant(direction);
++	leaveIntersection();
++	lock_release(lkQuadrant[direction]);
++
++	lock_release(lkPlanning);
++	// 08 Feb 2012 : GWA : Please do not change this code. This is so that your
++	// stoplight driver can return to the menu cleanly.
++	V(stoplightMenuSemaphore);
++	return;
+ }
+diff --git a/kern/syscall/file_syscalls.c b/kern/syscall/file_syscalls.c
+new file mode 100644
+index 0000000..b323c82
+--- /dev/null
++++ b/kern/syscall/file_syscalls.c
+@@ -0,0 +1,443 @@
++#include <types.h>
++#include <syscall.h>
++#include <lib.h>
++#include <vfs.h>
++#include <kern/errno.h>
++#include <thread.h>
++#include <kern/seek.h>
++#include <current.h>
++#include <lib.h>
++#include <kern/iovec.h>
++#include <uio.h>
++#include <kern/stat.h>
++#include <vnode.h>
++#include <copyinout.h>
++
++int createfd(struct thread* thread)
++{
++	int i;
++	for(i=3; i < (__OPEN_MAX) ; i++)
++		if (thread->filetable[i] == NULL )
++			return i;
++	return -1;	//file table full
++}
++/*
++Description
++open opens the file, device, or other kernel object named by the pathname filename. The flags argument specifies how to open the file. The optional mode argument is only meaningful in Unix (or if you choose to implement Unix-style security later on) and can be ignored.
++
++The flags argument should consist of one of
++
++    O_RDONLY		Open for reading only.
++    O_WRONLY		Open for writing only.
++    O_RDWR		Open for reading and writing.
++
++It may also have any of the following flags OR'd in:
++
++    O_CREAT		Create the file if it doesn't exist.
++    O_EXCL		Fail if the file already exists.
++    O_TRUNC		Truncate the file to length 0 upon open.
++    O_APPEND		Open the file in append mode.
++
++O_EXCL is only meaningful if O_CREAT is also used.
++
++O_APPEND causes all writes to the file to occur at the end of file, no matter what gets written to the file by whoever else. (This functionality may be optional; consult your course's assignments.)
++
++open returns a file handle suitable for passing to read, write, close, etc. This file handle must be greater than or equal to zero. Note that file handles 0 (STDIN_FILENO), 1 (STDOUT_FILENO), and 2 (STDERR_FILENO) are used in special ways and are typically assumed by user-level code to always be open.
++Return Values
++On success, open returns a nonnegative file handle. On error, -1 is returned, and errno is set according to the error encountered.
++Errors
++The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
++
++
++    ENODEV		The device prefix of filename did not exist.
++    ENOTDIR		A non-final component of filename was not a directory.
++    ENOENT		A non-final component of filename did not exist.
++    ENOENT		The named file does not exist, and O_CREAT was not specified.
++    EEXIST		The named file exists, and O_EXCL was specified.
++    EISDIR		The named object is a directory, and it was to be opened for writing.
++    EMFILE		The process's file table was full, or a process-specific limit on open files was reached.
++    ENFILE		The system file table is full, if such a thing exists, or a system-wide limit on open files was reached.
++    ENXIO		The named object is a block device with no mounted filesystem.
++    ENOSPC		The file was to be created, and the filesystem involved is full.
++    EINVAL		flags contained invalid values.
++    EIO		A hard I/O error occurred.
++    EFAULT		filename was an invalid pointer.
++ */
++int sys_open(userptr_t filename, int flags, int32_t *fd, ...)
++{
++	//	kprintf("FileName:%s, Flags:%d", (char*)filename, flags);
++	char kfilename[__PATH_MAX + __NAME_MAX + 1];
++
++
++	struct vnode *file_vnode;
++	int err;
++	size_t len;
++	err = copyinstr(filename, kfilename, __PATH_MAX + __NAME_MAX + 1, &len);
++	if(err)
++		return err;
++	err = vfs_open((char*)filename, flags, 0, &file_vnode);
++	if(err)
++		return err;
++	//No error we got a vnode now create a filediscriptor for it.
++	//TBD: we may not need to create a file discriptor
++	struct thread* cthread = (struct thread*)curthread;
++	*fd = createfd(cthread);
++	if(*fd < 0)
++		return ENFILE;
++
++	//only create this if its not already there.
++	struct filehandle *fh = kmalloc(sizeof(struct filehandle));
++	if(fh==NULL)
++		panic("Memory allocation for file handle failed");
++	fh->fileobject = file_vnode;
++	fh->offset = 0;
++	fh->open_mode = flags;
++	fh->lk_fileaccess = lock_create("filelock");
++	fh->refcount = 1;
++
++	// *fd = addtofiletable(fh);	we'll set fd once we implement filetable;
++	cthread->filetable[*fd] = fh;
++	//panic("fail open failed");
++	return 0;
++}
++
++/*
++Description
++read reads up to buflen bytes from the file specified by fd, at the location in the file specified by the current seek position of the file, and stores them in the space pointed to by buf. The file must be open for reading.
++
++The current seek position of the file is advanced by the number of bytes read.
++
++Each read (or write) operation is atomic relative to other I/O to the same file.
++
++Return Values
++The count of bytes read is returned. This count should be positive. A return value of 0 should be construed as signifying end-of-file. On error, read returns -1 and sets errno to a suitable error code for the error condition encountered.
++
++Note that in some cases, particularly on devices, fewer than buflen (but greater than zero) bytes may be returned. This depends on circumstances and does not necessarily signify end-of-file.
++
++Errors
++The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
++
++
++    EBADF		fd is not a valid file descriptor, or was not opened for reading.
++    EFAULT		Part or all of the address space pointed to by buf is invalid.
++    EIO		A hardware I/O error occurred reading the data.
++ */
++int sys_read(int fd, userptr_t buf, size_t buflen, int32_t *bytesread)
++{
++	if(fd<0||fd>=OPEN_MAX)
++		return EBADF;
++	struct filehandle* fh;
++	struct thread *cur = (struct thread*)curthread;
++	fh = cur->filetable[fd];
++	if(fh == NULL || (fh->open_mode & 1)!=0 )
++		return EBADF;
++
++	struct iovec iov;
++	struct uio ku;
++	char *readbuf = (char*)kmalloc(buflen);
++	lock_acquire(fh->lk_fileaccess);
++	uio_kinit(&iov, &ku, readbuf, buflen, fh->offset, UIO_READ);
++
++	int err = vfs_read(fh->fileobject, &ku);
++	if(err)
++		return err;
++	*bytesread = buflen - ku.uio_resid;
++	if(*bytesread==0){
++		lock_release(fh->lk_fileaccess);
++		kfree(readbuf);
++		return 0;
++	}
++
++	fh->offset += *bytesread;
++
++	lock_release(fh->lk_fileaccess);
++	err = copyout(readbuf, buf, *bytesread);
++	if(err)
++		return err;
++
++	kfree(readbuf);
++	return 0;
++}
++
++/*
++Description
++write writes up to buflen bytes to the file specified by fd, at the location in the file specified by the current seek position of the file, taking the data from the space pointed to by buf. The file must be open for writing.
++
++The current seek position of the file is advanced by the number of bytes written.
++
++Each write (or read) operation is atomic relative to other I/O to the same file.
++
++Return Values
++The count of bytes written is returned. This count should be positive. A return value of 0 means that nothing could be written, but that no error occurred; this only occurs at end-of-file on fixed-size objects. On error, write returns -1 and sets errno to a suitable error code for the error condition encountered.
++
++Note that in some cases, particularly on devices, fewer than buflen (but greater than zero) bytes may be written. This depends on circumstances and does not necessarily signify end-of-file. In most cases, one should loop to make sure that all output has actually been written.
++
++Errors
++The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
++
++
++    EBADF		fd is not a valid file descriptor, or was not opened for writing.
++    EFAULT		Part or all of the address space pointed to by buf is invalid.
++    ENOSPC		There is no free space remaining on the filesystem containing the file.
++    EIO		A hardware I/O error occurred writing the data.
++ */
++int sys_write(int fd, userptr_t buf, size_t nbytes, int32_t *byteswritten)
++{
++	if(fd<0||fd>=OPEN_MAX)
++		return EBADF;
++	struct filehandle* fh;
++	struct thread *cur = (struct thread*)curthread;
++	fh = cur->filetable[fd];
++	if(fh == NULL || (fh->open_mode & 3)==0 )
++		return EBADF;
++	char *writebuf = (char* )kmalloc(nbytes+1);
++	int result = copyin(buf, writebuf, nbytes);
++	if(result)
++		return result;
++	struct iovec iov;
++	struct uio ku;
++	lock_acquire(fh->lk_fileaccess);
++	uio_kinit(&iov, &ku, writebuf, nbytes, fh->offset, UIO_WRITE);
++	//ku.uio_space = cur->t_addrspace;
++	int err = vfs_write(fh->fileobject, &ku);
++	if(err)
++		return err;
++	*byteswritten = ku.uio_offset - fh->offset;
++	fh->offset += *byteswritten;
++	lock_release(fh->lk_fileaccess);
++	kfree(writebuf);
++	return 0;
++}
++
++/*
++Description
++lseek alters the current seek position of the file handle filehandle, seeking to a new position based on pos and whence.
++
++If whence is
++
++    SEEK_SET, the new position is pos.
++    SEEK_CUR, the new position is the current position plus pos.
++    SEEK_END, the new position is the position of end-of-file plus pos.
++    anything else, lseek fails.
++
++Note that pos is a signed quantity.
++
++It is not meaningful to seek on certain objects (such as the console device). All seeks on these objects fail.
++
++Seek positions less than zero are invalid. Seek positions beyond EOF are legal.
++
++Note that each distinct open of a file should have an independent seek pointer.
++
++Return Values
++On success, lseek returns the new position. On error, -1 is returned, and errno is set according to the error encountered.
++Errors
++The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
++
++
++    EBADF		fd is not a valid file handle.
++    ESPIPE		fd refers to an object which does not support seeking.
++    EINVAL		whence is invalid.
++    EINVAL		The resulting seek position would be negative.
++ */
++int sys_lseek(int fd, off_t pos, int sp, int32_t *offsethigh, int32_t *offsetlow)
++{
++	if(fd<0||fd>=OPEN_MAX)
++		return EBADF;
++	if(fd<3)
++		return ESPIPE;
++	int whence;
++	int err = copyin((userptr_t)sp+16, &whence, sizeof(int32_t));
++
++	if(whence <0 || whence >2)
++		return EINVAL;
++	struct filehandle* fh;
++	struct thread *cur = (struct thread*)curthread;
++	fh = cur->filetable[fd];
++	if(fh == NULL )
++		return EBADF;
++	lock_acquire(fh->lk_fileaccess);
++	off_t newpos;
++	if(whence == SEEK_SET)
++		newpos = 0;
++	else if(whence == SEEK_END)
++	{
++		struct stat filestat;
++		VOP_STAT(fh->fileobject, &filestat);
++		newpos = filestat.st_size;
++	}
++	else
++	{
++		newpos = fh->offset;
++	}
++	err =vfs_lseek(fh->fileobject, newpos + pos);
++	if(err)
++		return err;
++	fh->offset = newpos + pos;
++	// else whence is SEEK_CUR
++
++	off_t ofst = fh->offset;
++	*offsetlow = (int32_t)ofst;
++	ofst = ofst >> 32;
++	*offsethigh = (int32_t)ofst;
++
++	lock_release(fh->lk_fileaccess);
++	return 0;
++}
++
++/*
++Description
++The file handle fd is closed. The same file handle may then be returned again from open, dup2, pipe, or similar calls.
++
++Other file handles are not affected in any way, even if they are attached to the same file.
++
++Return Values
++On success, close returns 0. On error, -1 is returned, and errno is set according to the error encountered.
++Errors
++The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
++
++
++    EBADF		fd is not a valid file handle.
++    EIO		A hard I/O error occurred.
++ */
++int sys_close(int fd)
++{
++	if(fd<0||fd>=OPEN_MAX)
++		return EBADF;
++	struct filehandle* fh;
++	struct thread *cur = (struct thread*)curthread;
++	fh = cur->filetable[fd];
++	if(fh == NULL)
++		return EBADF;
++	fh->refcount --;
++	if(fh->refcount == 0)
++	{
++		vfs_close(fh->fileobject);
++		kfree(fh);
++	}
++	cur->filetable[fd] = NULL;
++	//	while(1);
++	return 0;
++}
++
++/*
++ Description
++dup2 clones the file handle oldfd onto the file handle newfd. If newfd names an open file, that file is closed.
++
++The two handles refer to the same "open" of the file - that is, they are references to the same object and share the same seek pointer. Note that this is different from opening the same file twice.
++
++dup2 is most commonly used to relocate opened files onto STDIN_FILENO, STDOUT_FILENO, and/or STDERR_FILENO.
++
++Both filehandles must be non-negative.
++
++Using dup2 to clone a file handle onto itself has no effect.
++
++(The "2" in "dup2" arises from the existence of an older and less powerful Unix system call "dup".)
++Return Values
++dup2 returns newfd. On error, -1 is returned, and errno is set according to the error encountered.
++Errors
++The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
++
++
++    EBADF		oldfd is not a valid file handle, or newfd is a value that cannot be a valid file handle.
++    EMFILE		The process's file table was full, or a process-specific limit on open files was reached.
++ */
++int sys_dup2(int oldfd, int newfd, int * retval)
++{
++	//oldfd should be valid,newfd should be valid
++	//newfd location must be empty
++	//File table full or limit reached
++	if(oldfd<0 ||oldfd >=__OPEN_MAX){
++		return EBADF;
++	}
++	struct filehandle* fh;
++	struct thread *cur = (struct thread*)curthread;
++	fh = cur->filetable[oldfd];
++	if(fh == NULL){
++		return EBADF;
++	}
++	if(newfd<0||newfd>=__OPEN_MAX){
++		return EBADF;
++	}else{
++		fh = cur->filetable[newfd];
++	    if((newfd!=oldfd)&&fh != NULL){
++	            sys_close(newfd);
++	        }
++		cur->filetable[newfd] = cur->filetable[oldfd];
++		*retval=newfd;
++		return 0;
++	}
++
++}
++
++/*
++ * Description
++The current directory of the current process is set to the directory named by pathname.
++
++Return Values
++On success, chdir returns 0. On error, -1 is returned, and errno is set according to the error encountered.
++Errors
++The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
++
++
++    ENODEV		The device prefix of pathname did not exist.
++    ENOTDIR		A non-final component of pathname was not a directory.
++    ENOTDIR		pathname did not refer to a directory.
++    ENOENT		pathname did not exist.
++    EIO		A hard I/O error occurred.
++    EFAULT		pathname was an invalid pointer.
++ */
++int sys_chdir(userptr_t pathname)
++{
++	char kfilename[__PATH_MAX + __NAME_MAX + 1];
++	int err;
++	size_t len;
++	err = copyinstr(pathname, kfilename, __PATH_MAX + __NAME_MAX + 1, &len);
++	if(err)
++		return err;
++	//didn use kfilename?
++	err = vfs_chdir((char*)kfilename);
++	if(err)
++		return err;
++
++	return 0;
++}
++
++
++/*
++Description
++The name of the current directory is computed and stored in buf, an area of size buflen. The length of data actually stored, which must be non-negative, is returned.
++
++Note: this call behaves like read - the name stored in buf is not 0-terminated.
++
++This function is not meant to be called except by the C library; application programmers should use getcwd instead.
++Return Values
++On success, __getcwd returns the length of the data returned. On error, -1 is returned, and errno is set according to the error encountered.
++Errors
++The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
++
++
++    ENOENT		A component of the pathname no longer exists.
++    EIO			A hard I/O error occurred.
++    EFAULT		buf points to an invalid address.
++ */
++int sys___getcwd(userptr_t buf, size_t buflen, int32_t *ret)
++{
++	if(buflen > PATH_MAX)
++		buflen = PATH_MAX;
++	//	struct thread *cur = (struct thread*)curthread;
++	struct iovec iov;
++	struct uio ku;
++	char *readbuf = (char*)kmalloc(buflen);
++	uio_kinit(&iov, &ku, readbuf, buflen, 0, UIO_READ);
++	int err = vfs_getcwd(&ku);
++	if(err)
++		return err;
++	*ret = buflen - ku.uio_resid;
++	err = copyout(readbuf, buf, *ret);
++	if(err)
++		return err;
++
++	kfree(readbuf);
++
++	return *ret;
++}
+diff --git a/kern/syscall/proc_syscalls.c b/kern/syscall/proc_syscalls.c
+new file mode 100644
+index 0000000..85d19e7
+--- /dev/null
++++ b/kern/syscall/proc_syscalls.c
+@@ -0,0 +1,493 @@
++#include <types.h>
++#include <syscall.h>
++#include <kern/errno.h>
++#include <kern/fcntl.h>
++#include <lib.h>
++#include <thread.h>
++#include <current.h>
++#include <addrspace.h>
++#include <vm.h>
++#include <vfs.h>
++#include <syscall.h>
++#include <test.h>
++#include <mips/trapframe.h>
++#include <synch.h>
++#include <copyinout.h>
++#include <kern/wait.h>
++void clonetrapframe(struct trapframe *inframe, struct trapframe *returnframe)
++{
++	//struct trapframe* returnframe = kmalloc(sizeof(struct trapframe));
++
++	returnframe->tf_vaddr = inframe->tf_vaddr;	/* coprocessor 0 vaddr register */
++	returnframe->tf_status = inframe->tf_status;	/* coprocessor 0 status register */
++	returnframe->tf_cause = inframe->tf_cause;	/* coprocessor 0 cause register */
++	returnframe->tf_lo = inframe->tf_lo;
++	returnframe->tf_hi = inframe->tf_hi;
++	returnframe->tf_ra = inframe->tf_ra;		/* Saved register 31 */
++	returnframe->tf_at = inframe->tf_at;		/* Saved register 1 (AT) */
++	returnframe->tf_v0 = inframe->tf_v0;		/* Saved register 2 (v0) */
++	returnframe->tf_v1 = inframe->tf_v1;		/* etc. */
++	returnframe->tf_a0 = inframe->tf_a0;
++	returnframe->tf_a1 = inframe->tf_a1;
++	returnframe->tf_a2 = inframe->tf_a2;
++	returnframe->tf_a3 = inframe->tf_a3;
++	returnframe->tf_t0 = inframe->tf_t0;
++	returnframe->tf_t1 = inframe->tf_t1;
++	returnframe->tf_t2 = inframe->tf_t2;
++	returnframe->tf_t3 = inframe->tf_t3;
++	returnframe->tf_t4 = inframe->tf_t4;
++	returnframe->tf_t5 = inframe->tf_t5;
++	returnframe->tf_t6 = inframe->tf_t6;
++	returnframe->tf_t7 = inframe->tf_t7;
++	returnframe->tf_s0 = inframe->tf_s0;
++	returnframe->tf_s1 = inframe->tf_s1;
++	returnframe->tf_s2 = inframe->tf_s2;
++	returnframe->tf_s3 = inframe->tf_s3;
++	returnframe->tf_s4 = inframe->tf_s4;
++	returnframe->tf_s5 = inframe->tf_s5;
++	returnframe->tf_s6 = inframe->tf_s6;
++	returnframe->tf_s7 = inframe->tf_s7;
++	returnframe->tf_t8 = inframe->tf_t8;
++	returnframe->tf_t9 = inframe->tf_t9;
++	returnframe->tf_k0 = inframe->tf_k0;		/* dummy (see exception.S comments) */
++	returnframe->tf_k1 = inframe->tf_k1;		/* dummy */
++	returnframe->tf_gp = inframe->tf_gp;
++	returnframe->tf_sp = inframe->tf_sp;
++	returnframe->tf_s8 = inframe->tf_s8;
++	returnframe->tf_epc = inframe->tf_epc;
++
++	//return returnframe;
++}
++
++/*
++ *
++ * Name
++getpid - get process id
++Library
++Standard C Library (libc, -lc)
++Synopsis
++#include <unistd.h>
++
++pid_t
++getpid(void);
++Description
++getpid returns the process id of the current process.
++Errors
++getpid does not fail.
++ */
++
++pid_t sys_getpid(void)
++{
++	return curthread->pid;
++}
++
++
++/*
++ *
++ * Name
++fork - copy the current process
++Library
++Standard C Library (libc, -lc)
++Synopsis
++#include <unistd.h>
++
++pid_t
++fork(void);
++Description
++fork duplicates the currently running process. The two copies are identical, except that one (the "new" one, or "child"), has a new, unique process id, and in the other (the "parent") the process id is unchanged.
++
++The process id must be greater than 0.
++
++The two processes do not share memory or open file tables; this state is copied into the new process, and subsequent modification in one process does not affect the other.
++
++However, the file handle objects the file tables point to are shared, so, for instance, calls to lseek in one process can affect the other.
++
++Return Values
++On success, fork returns twice, once in the parent process and once in the child process. In the child process, 0 is returned. In the parent process, the process id of the new child process is returned.
++
++On error, no new process is created, fork only returns once, returning -1, and errno is set according to the error encountered.
++Errors
++The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
++
++
++    EMPROC		The current user already has too many processes.
++    ENPROC		There are already too many processes on the system.
++    ENOMEM		Sufficient virtual memory for the new process was not available.
++ */
++
++struct message
++{
++	struct trapframe *tf;
++	struct addrspace *as;
++	struct semaphore *sem;
++	int *pid;
++};
++
++int sys_fork(struct trapframe *ptf, pid_t *pid)
++{
++	//clone the parent trapframe
++
++	//TODO: Currently leaking this part of memory need to fix this
++	//struct trapframe *tf = kmalloc(sizeof(struct trapframe));
++	//clonetrapframe(ptf, tf);
++
++	struct addrspace *childas = NULL;
++	int err = as_copy(curthread->t_addrspace, &childas);	//copy parent address space
++	if(err)
++		return err;
++	struct message* msg = kmalloc(sizeof(struct message));
++
++	struct semaphore* s = sem_create("forksem",0);
++	msg->as = childas;
++	msg->tf= ptf;
++	msg->sem = s;
++	msg->pid = kmalloc(sizeof(int));
++	struct thread* child=NULL;
++	err = thread_fork("child", &child_fork, (void*)msg, 0, &child );
++	P(s);
++	*pid = *(msg->pid);
++	kfree(msg->sem);
++	kfree(msg->pid);
++	kfree(msg);
++
++	if(err)
++		return err;
++	return 0;
++}
++
++/*
++ * Name
++execv - execute a program
++Library
++Standard C Library (libc, -lc)
++Synopsis
++#include <unistd.h>
++
++int
++execv(const char *program, char **args);
++Description
++execv replaces the currently executing program with a newly loaded program image. This occurs within one process; the process id is unchanged.
++
++The pathname of the program to run is passed as program. The args argument is an array of 0-terminated strings. The array itself should be terminated by a NULL pointer.
++
++The argument strings should be copied into the new process as the new process's argv[] array. In the new process, argv[argc] must be NULL.
++
++By convention, argv[0] in new processes contains the name that was used to invoke the program. This is not necessarily the same as program, and furthermore is only a convention and should not be enforced by the kernel.
++
++The process file table and current working directory are not modified by execve.
++Return Values
++On success, execv does not return; instead, the new program begins executing. On failure, execv returns -1, and sets errno to a suitable error code for the error condition encountered.
++Errors
++The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
++
++
++    ENODEV		The device prefix of program did not exist.
++    ENOTDIR		A non-final component of program was not a directory.
++    ENOENT		program did not exist.
++    EISDIR		program is a directory.
++    ENOEXEC		program is not in a recognizable executable file format, was for the wrong platform, or contained invalid fields.
++    ENOMEM		Insufficient virtual memory is available.
++    E2BIG		The total size of the argument strings is too large.
++    EIO		A hard I/O error occurred.
++    EFAULT		One of the args is an invalid pointer.
++ */
++
++int sys_execv(userptr_t prog, userptr_t argsptr)
++{
++	char *program = kmalloc(1000);
++	size_t proglen;
++
++	int err = copyin(argsptr, program,1); // doing this just to make sure its valid address
++	if(err)
++	{
++			kfree(program);
++			return EFAULT;
++	}
++
++	err = copyinstr(prog, program, 1000, &proglen);
++	if(err)
++	{
++			kfree(program);
++			return EFAULT;
++	}
++	if(err)
++	{
++		kfree(program);
++		return EFAULT;
++	}
++	char** args=(char**)argsptr;
++	struct vnode *v;
++	vaddr_t entrypoint, stackptr;
++	int result;
++
++	//Copy the arguments into kernel buffer
++	unsigned long j=0;
++	size_t strlen=0;
++	int size=0;
++	unsigned long argc;
++	//Calculate the size of the array to allocate
++	char * tempArgs=kmalloc(1000);
++
++	while(args[j]!=NULL){
++		//strlen = kstrcpy(args[j], tempArgs);//
++		err = copyinstr((userptr_t)(args[j]), tempArgs, 1000,&strlen);
++		if(err)
++		{
++			kfree(tempArgs);
++			return EFAULT;
++		}
++		strlen=strlen + 4 - strlen%4;
++		size+=strlen;
++		j++;
++	}
++	argc=j;
++	//Add space for 4 integers
++	size+=argc*4;
++	size+=4;//for Null
++
++	char * kargv= kmalloc(size);
++	int top=argc*4+4;
++	j=0;
++	while(args[j]!=NULL){
++		strlen=0;
++		*((int*)(kargv + j*4))=top;
++	//	strlen = kstrcpy(args[j], kargv+top);//
++		copyinstr((userptr_t)args[j], kargv+top, 1000,&strlen);
++		top+=strlen;
++		while(top%4!=0){
++			*(kargv+top)='\0';
++			top++;
++		}
++		j++;
++	}
++	int * ka = (int*)(kargv + j*4);
++	*(ka)=0;
++	//kargv is constructed
++
++	/* Open the file. */
++	result = vfs_open((char*)program, O_RDONLY, 0, &v);
++	if (result) {
++		return result;
++	}
++
++	/* Load the executable. */
++	result = load_elf(v, &entrypoint);
++	if (result) {
++		/* thread_exit destroys curthread->t_addrspace */
++		vfs_close(v);
++		return result;
++	}
++
++	/* Done with the file now. */
++	vfs_close(v);
++
++	/* Define the user stack in the address space */
++	result = as_define_stack(curthread->t_addrspace, &stackptr);
++	if (result) {
++		/* thread_exit destroys curthread->t_addrspace */
++		return result;
++	}
++
++	//Copy the arguments to userstack
++	j=0;
++	int * userAddr=(int *)(stackptr-size);
++
++	while(j<argc){
++		ka = (int*)(kargv + j*4);
++		*ka=*ka+(int)userAddr;
++		//userAddr+=2;
++		j++;
++	}
++	copyout(kargv, (userptr_t)userAddr, (size_t)size);
++	//Copied to user space
++	kfree(tempArgs);
++	kfree(kargv);
++	/* Warp to user mode. */
++	enter_new_process(argc, (userptr_t)(userAddr),(vaddr_t)(userAddr), entrypoint);
++
++	/* enter_new_process does not return. */
++	panic("enter_new_process returned\n");
++	return EINVAL;
++}
++/*
++ * Name
++waitpid - wait for a process to exit
++Library
++Standard C Library (libc, -lc)
++Synopsis
++#include <sys/wait.h>
++
++pid_t
++waitpid(pid_t pid, int *status, int options);
++Description
++Wait for the process specified by pid to exit, and return an encoded exit status in the integer pointed to by status. If that process has exited already, waitpid returns immediately. If that process does not exist, waitpid fails.
++
++What it means for a process to move from "has exited already" to "does not exist", and when this occurs, is something you must decide.
++
++If process P is "interested" in the exit code of process Q, process P should be able to find out that exit code by calling waitpid, even if Q exits somewhat before the time P calls waitpid. As described under _exit(), precisely what is meant by "interested" is up to you.
++
++You might implement restrictions or requirements on who may wait for which processes, like Unix does. You might also add a system call for one process to express interest in another process's exit code. If you do this, be sure to write a man page for the system call, and discuss the rationale for your choices therein in your design document.
++
++Note that in the absence of restrictions on who may wait for what, it is possible to set up situations that may result in deadlock. Your system must (of course) in some manner protect itself from these situations, either by prohibiting them or by detecting and resolving them.
++
++In order to make the userlevel code that ships with OS/161 work, assume that a parent process is always interested in the exit codes of its child processes generated with fork(), unless it does something special to indicate otherwise.
++
++The options argument should be 0. You are not required to implement any options. (However, your system should check to make sure that options you do not support are not requested.)
++
++If you desire, you may implement the Unix option WNOHANG; this causes waitpid, when called for a process that has not yet exited, to return 0 immediately instead of waiting.
++
++The Unix option WUNTRACED, to ask for reporting of processes that stop as well as exit, is also defined in the header files, but implementing this feature is not required or necessary unless you are implementing job control.
++
++You may also make up your own options if you find them helpful. However, please, document anything you make up.
++
++The encoding of the exit status is comparable to Unix and is defined by the flags found in <kern/wait.h>. (Userlevel code should include <sys/wait.h> to get these definitions.) A process can exit by calling _exit() or it can exit by receiving a fatal signal. In the former case the _MKWAIT_EXIT() macro should be used with the user-supplied exit code to prepare the exit status; in the latter, the _MKWAIT_SIG() macro (or _MKWAIT_CORE() if a core file was generated) should be used with the signal number. The result encoding also allows notification of processes that have stopped; this would be used in connection with job control and with ptrace-based debugging if you were to implement those things.
++
++To read the wait status, use the macros WIFEXITED(), WIFSIGNALED(), and/or WIFSTOPPED() to find out what happened, and then WEXITSTATUS(), WTERMSIG(), or WSTOPSIG() respectively to get the exit code or signal number. If WIFSIGNALED() is true, WCOREDUMP() can be used to check if a core file was generated. This is the same as Unix, although the value encoding is different from the historic Unix format.
++
++Return Values
++waitpid returns the process id whose exit status is reported in status. In OS/161, this is always the value of pid.
++
++If you implement WNOHANG, and WNOHANG is given, and the process specified by pid has not yet exited, waitpid returns 0.
++
++(In Unix, but not by default OS/161, you can wait for any of several processes by passing magic values of pid, so this return value can actually be useful.)
++
++On error, -1 is returned, and errno is set to a suitable error code for the error condition encountered.
++Errors
++The following error codes should be returned under the conditions given. Other error codes may be returned for other errors not mentioned here.
++
++
++    EINVAL		The options argument requested invalid or unsupported options.
++    ECHILD		The pid argument named a process that the current process was not interested in or that has not yet exited.
++    ESRCH		The pid argument named a nonexistent process.
++    EFAULT		The status argument was an invalid pointer.
++ */
++int sys_waitpid(pid_t pid, userptr_t status, int options, int *retval, int iskernspace)
++{
++	if(options!=0)
++		return EINVAL;
++
++	//if waitOnThread==NULL or exitSemaphore[i]==NULL(Thread exited or does not exist)
++	//then exitCode[i]==-1 thread does not exist or exit code collected
++	//else thread existed, exited and its exit code yet to be collected
++	//oderwise thread currently active. Do a P() on exitSemaphone[i].
++	//on V(), check exitCode[i], if it is nt -1 then return it and set it to -1
++	//else error
++
++	//As described under _exit(), precisely what is meant by "interested" is up to you...Decide on this
++	//TO allow only parents to wait on child, check if current threads Pid is PPID of the child thread. But this wont work with already exited thread.
++	//Status yet to understand
++	int exit = 0;
++	if(iskernspace == 0)//copysomevalue to check if its valid
++	{
++		int err = copyout(&exit, status, sizeof(int));
++		if(err)
++			return err;
++	}
++
++
++	if(pid<PID_MIN || pid > PID_MAX)
++		return ESRCH;
++	if(g_pidlist[pid]==NULL){
++		//The pid argument named a nonexistent process.
++		return ESRCH;
++	}
++	//Child Thread is still executing. Do a P() on the corresponding Semaphore.P will return immediately for a Zombie thread.
++	//We will allow only parent to collect exitcode of child. This defines what "Interested" means and will also ensure that there is no deadlock
++	struct thread* waitOnThread=g_pidlist[pid]->thread;
++
++	//TODO: need to add PPID to pidentry struct only parent should be able to collect
++	if(waitOnThread!=NULL && curthread->pid!=waitOnThread->ppid)
++		return ECHILD;
++	P(g_pidlist[pid]->sem);
++
++	exit = _MKWAIT_EXIT(g_pidlist[pid]->exitstatus);
++		if(iskernspace == 1)
++		{
++			*((int*)status) = g_pidlist[pid]->exitstatus;
++		}
++		else
++		{
++			int err = copyout(&exit, status, sizeof(int));
++			if(err)
++				return err;
++		}
++
++	sem_destroy(g_pidlist[pid]->sem);
++	kfree(g_pidlist[pid]);
++	g_pidlist[pid]=NULL;
++	*retval=pid;
++	return 0;
++
++}
++
++/*
++ * Name
++_exit - terminate process
++Library
++Standard C Library (libc, -lc)
++Synopsis
++#include <unistd.h>
++
++void
++_exit(int exitcode);
++Description
++Cause the current process to exit. The exit code exitcode is reported back to other process(es) via the waitpid() call. The process id of the exiting process should not be reused until all processes interested in collecting the exit code with waitpid have done so. (What "interested" means is intentionally left vague; you should design this.)
++Return Values
++_exit does not return.
++ */
++
++void sys_exit(int exitcode)
++{
++	int pid=curthread->pid;
++	g_pidlist[pid]->exitstatus=exitcode;//_MKWAIT_EXIT(exitcode);
++	g_pidlist[pid]->thread = NULL;
++	V(g_pidlist[pid]->sem);
++	thread_exit();
++}
++
++
++void child_fork(void* data1, unsigned long data2)
++{
++	struct message *msg = (struct message *) data1;
++	struct trapframe* ptf = msg->tf;
++	struct addrspace* as = msg->as;
++	(void)data2;
++	curthread->t_addrspace = as;
++	as_activate(curthread->t_addrspace);
++
++	*(msg->pid) = curthread->pid;
++	struct trapframe tf;
++	clonetrapframe(ptf, &tf);
++
++	tf.tf_a3 = 0;
++	tf.tf_v0 = 0;
++	tf.tf_epc += 4;
++
++	//kfree(ptf);
++
++	V(msg->sem);
++
++
++	mips_usermode(&tf);
++
++}
++
++int createpid(struct thread* newthread, pid_t *ret)
++{
++	pid_t i;
++	lock_acquire(g_lk_pid);
++	for(i=3; i<PID_MAX; i++)
++		if(g_pidlist[i] == NULL)
++		{
++			struct pidentry *pident = kmalloc(sizeof(struct pidentry));
++			pident->exitstatus = 0;
++			pident->thread = newthread;
++			pident->sem = sem_create("threadsem", 0);
++			g_pidlist[i]= pident;
++			*ret = i;
++			lock_release(g_lk_pid);
++			return 0;
++		}
++	lock_release(g_lk_pid);
++	return ENPROC;
++}
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..9fd3e7b 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,6 +44,19 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include <copyinout.h>
++
++int kstrcpy(char* src, char* dest)
++{
++	int i=0;
++	while(src[i] != '\0')
++	{
++		dest[i] = src[i];
++		i++;
++	}
++	dest[i++]= '\0';
++	return i;
++}
+ 
+ /*
+  * Load program "progname" and start running it in usermode.
+@@ -52,12 +65,53 @@
+  * Calls vfs_open on progname and thus may destroy it.
+  */
+ int
+-runprogram(char *progname)
++runprogram(char *progname,char** args, unsigned long nargs)
+ {
+ 	struct vnode *v;
+ 	vaddr_t entrypoint, stackptr;
+ 	int result;
+ 
++	//Copy the arguments into kernel buffer
++	unsigned long j=0;
++	size_t strlen=0;
++	int size=0;
++	unsigned long argc;
++	//Calculate the size of the array to allocate
++	char * tempArgs=kmalloc(1000);
++
++	while(j< nargs){
++		strlen = kstrcpy(args[j], tempArgs);//copyinstr((userptr_t)(args[j]), tempArgs, 1000,&strlen);
++		strlen=strlen + 4 - strlen%4;
++		size+=strlen;
++		j++;
++	}
++	argc=j;
++	//Add space for 4 integers
++	size+=argc*4;
++	size+=4;//for Null
++
++	char * kargv= kmalloc(size);
++	int top=argc*4+4;
++	j=0;
++	while(j< nargs){
++		strlen=0;
++		*((int*)(kargv + j*4))=top;
++		strlen = kstrcpy(args[j], kargv+top);//copyinstr((userptr_t)args[j], kargv+top, 1000,&strlen);
++		top+=strlen;
++		while(top%4!=0){
++			*(kargv+top)='\0';
++			top++;
++		}
++		j++;
++	}
++	int * ka = (int*)(kargv + j*4);
++	*(ka)=0;
++
++	//kargv is constructed
++
++
++
++
+ 	/* Open the file. */
+ 	result = vfs_open(progname, O_RDONLY, 0, &v);
+ 	if (result) {
+@@ -95,12 +149,118 @@ runprogram(char *progname)
+ 		return result;
+ 	}
+ 
++
++
++	//Initializing STD IN
++	struct vnode *std;
++	char con[5] = "con:";
++	int err = vfs_open(con, O_RDONLY, 0x660, &std);
++	if(err)
++		KASSERT("Initializing STDIN failed");
++	struct filehandle *fh = kmalloc(sizeof(struct filehandle));
++	if(fh==NULL)
++		KASSERT("Memory allocation for file handle failed");
++	fh->fileobject = std;
++	fh->offset = 0;
++	fh->open_mode = O_RDONLY;
++	fh->lk_fileaccess = lock_create("filelock");
++	fh->refcount = 0;
++
++	// *fd = addtofiletable(fh);	we'll set fd once we implement filetable;
++	curthread->filetable[0] = fh;
++
++	//Initializing STDOUT
++	err = vfs_open(con, O_WRONLY, 0x660, &std);
++	if(err)
++		KASSERT("Initializing STDOUT failed");
++	fh = kmalloc(sizeof(struct filehandle));
++	if(fh==NULL)
++		KASSERT("Memory allocation for file handle failed");
++	fh->fileobject = std;
++	fh->offset = 0;
++	fh->open_mode = O_WRONLY;
++	fh->lk_fileaccess = lock_create("filelock");
++	fh->refcount = 0;
++
++
++	// *fd = addtofiletable(fh);	we'll set fd once we implement filetable;
++	curthread->filetable[1] = fh;
++
++	//Initializing STDERR
++	err = vfs_open(con, O_WRONLY, 0660, &std);
++	if(err)
++		KASSERT("Initializing STDERR failed");
++	fh = kmalloc(sizeof(struct filehandle));
++	if(fh==NULL)
++		panic("Memory allocation for file handle failed");
++	fh->fileobject = std;
++	fh->offset = 0;
++	fh->open_mode = O_WRONLY;
++	fh->lk_fileaccess = lock_create("filelock");
++	fh->refcount = 0;
++
++
++	// *fd = addtofiletable(fh);	we'll set fd once we implement filetable;
++	curthread->filetable[2] = fh;
++
++	//initialize filetable to NULL except for STDIO
++	int i;
++	for(i=3; i < OPEN_MAX;i++)
++		curthread->filetable[i] = NULL;
++
++
++
++	//	lock_acquire(&g_lk_pid);
++	for(i=3; i<PID_MAX; i++)
++	{
++		g_pidlist[i]= NULL;
++	}
++	//	lock_release(&g_lk_pid);
++
++	//let us assume this is the init process/thread set the pid to 1
++	curthread->pid = PID_MIN;
++	curthread->ppid = 0;
++	struct pidentry* pident = kmalloc(sizeof(struct pidentry));
++	pident->exitstatus = 0;
++	pident->thread = curthread;
++	pident->sem = sem_create("threadsem", 0);
++	g_pidlist[PID_MIN] = pident;
++
++	V(g_runprogsem);
++
++
++
++
++	//Copy the arguments to userstack
++	j=0;
++	int * userAddr=(int *)(stackptr-size);
++
++	while(j<argc){
++		ka = (int*)(kargv + j*4);
++		*ka=*ka+(int)userAddr;
++		//userAddr+=2;
++		j++;
++	}
++	copyout(kargv, (userptr_t)userAddr, (size_t)size);
++	//Copied to user space
++
++	char* copyinstack = kmalloc(size);
++	copyin((userptr_t)userAddr,(void *)copyinstack,(size_t)size);
++
++	int k=0;
++	for(k=0;k<size;k++)
++	{
++		kprintf("%c", copyinstack[i]);
++	}
++	//while(1);
++	/* Warp to user mode. */
++	enter_new_process(argc, (userptr_t)(userAddr),(vaddr_t)(userAddr), entrypoint);
++
+ 	/* Warp to user mode. */
+-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+-			  stackptr, entrypoint);
+-	
++	//	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
++	//			stackptr, entrypoint);
++
+ 	/* enter_new_process does not return. */
+ 	panic("enter_new_process returned\n");
+ 	return EINVAL;
+ }
+-
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..651a2ab 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -47,20 +47,20 @@
+ struct semaphore *
+ sem_create(const char *name, int initial_count)
+ {
+-        struct semaphore *sem;
++	struct semaphore *sem;
+ 
+-        KASSERT(initial_count >= 0);
++	KASSERT(initial_count >= 0);
+ 
+-        sem = kmalloc(sizeof(struct semaphore));
+-        if (sem == NULL) {
+-                return NULL;
+-        }
++	sem = kmalloc(sizeof(struct semaphore));
++	if (sem == NULL) {
++		return NULL;
++	}
+ 
+-        sem->sem_name = kstrdup(name);
+-        if (sem->sem_name == NULL) {
+-                kfree(sem);
+-                return NULL;
+-        }
++	sem->sem_name = kstrdup(name);
++	if (sem->sem_name == NULL) {
++		kfree(sem);
++		return NULL;
++	}
+ 
+ 	sem->sem_wchan = wchan_create(sem->sem_name);
+ 	if (sem->sem_wchan == NULL) {
+@@ -70,38 +70,38 @@ sem_create(const char *name, int initial_count)
+ 	}
+ 
+ 	spinlock_init(&sem->sem_lock);
+-        sem->sem_count = initial_count;
++	sem->sem_count = initial_count;
+ 
+-        return sem;
++	return sem;
+ }
+ 
+ void
+ sem_destroy(struct semaphore *sem)
+ {
+-        KASSERT(sem != NULL);
++	KASSERT(sem != NULL);
+ 
+ 	/* wchan_cleanup will assert if anyone's waiting on it */
+ 	spinlock_cleanup(&sem->sem_lock);
+ 	wchan_destroy(sem->sem_wchan);
+-        kfree(sem->sem_name);
+-        kfree(sem);
++	kfree(sem->sem_name);
++	kfree(sem);
+ }
+ 
+ void 
+ P(struct semaphore *sem)
+ {
+-        KASSERT(sem != NULL);
++	KASSERT(sem != NULL);
+ 
+-        /*
+-         * May not block in an interrupt handler.
+-         *
+-         * For robustness, always check, even if we can actually
+-         * complete the P without blocking.
+-         */
+-        KASSERT(curthread->t_in_interrupt == false);
++	/*
++	 * May not block in an interrupt handler.
++	 *
++	 * For robustness, always check, even if we can actually
++	 * complete the P without blocking.
++	 */
++	KASSERT(curthread->t_in_interrupt == false);
+ 
+ 	spinlock_acquire(&sem->sem_lock);
+-        while (sem->sem_count == 0) {
++	while (sem->sem_count == 0) {
+ 		/*
+ 		 * Bridge to the wchan lock, so if someone else comes
+ 		 * along in V right this instant the wakeup can't go
+@@ -120,24 +120,24 @@ P(struct semaphore *sem)
+ 		 */
+ 		wchan_lock(sem->sem_wchan);
+ 		spinlock_release(&sem->sem_lock);
+-                wchan_sleep(sem->sem_wchan);
++		wchan_sleep(sem->sem_wchan);
+ 
+ 		spinlock_acquire(&sem->sem_lock);
+-        }
+-        KASSERT(sem->sem_count > 0);
+-        sem->sem_count--;
++	}
++	KASSERT(sem->sem_count > 0);
++	sem->sem_count--;
+ 	spinlock_release(&sem->sem_lock);
+ }
+ 
+ void
+ V(struct semaphore *sem)
+ {
+-        KASSERT(sem != NULL);
++	KASSERT(sem != NULL);
+ 
+ 	spinlock_acquire(&sem->sem_lock);
+ 
+-        sem->sem_count++;
+-        KASSERT(sem->sem_count > 0);
++	sem->sem_count++;
++	KASSERT(sem->sem_count > 0);
+ 	wchan_wakeone(sem->sem_wchan);
+ 
+ 	spinlock_release(&sem->sem_lock);
+@@ -150,59 +150,98 @@ V(struct semaphore *sem)
+ struct lock *
+ lock_create(const char *name)
+ {
+-        struct lock *lock;
+-
+-        lock = kmalloc(sizeof(struct lock));
+-        if (lock == NULL) {
+-                return NULL;
+-        }
+-
+-        lock->lk_name = kstrdup(name);
+-        if (lock->lk_name == NULL) {
+-                kfree(lock);
+-                return NULL;
+-        }
+-        
+-        // add stuff here as needed
+-        
+-        return lock;
++	struct lock *lock;
++
++	lock = kmalloc(sizeof(struct lock));
++	if (lock == NULL) {
++		return NULL;
++	}
++
++	lock->lk_name = kstrdup(name);
++	if (lock->lk_name == NULL) {
++		kfree(lock);
++		return NULL;
++	}
++
++	lock->lk_wchan = wchan_create(lock->lk_name);
++	if (lock->lk_wchan == NULL) {
++		kfree(lock->lk_name);
++		kfree(lock);
++		return NULL;
++	}
++
++	spinlock_init(&lock->lk_lock);
++	lock->lk_held = false;
++
++	return lock;
+ }
+ 
+ void
+ lock_destroy(struct lock *lock)
+ {
+-        KASSERT(lock != NULL);
++	KASSERT(lock != NULL);
+ 
+-        // add stuff here as needed
+-        
+-        kfree(lock->lk_name);
+-        kfree(lock);
++
++	/* wchan_cleanup will assert if anyone's waiting on it */
++	spinlock_cleanup(&lock->lk_lock);
++	wchan_destroy(lock->lk_wchan);
++
++	kfree(lock->lk_name);
++	kfree(lock);
+ }
+ 
+ void
+ lock_acquire(struct lock *lock)
+ {
+-        // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++	KASSERT(lock != NULL);
++
++	/*
++	 * May not block in an interrupt handler.
++	 *
++	 * For robustness, always check, even if we can actually
++	 * complete the acquire without blocking.
++	 */
++	KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->lk_lock);
++	while (lock->lk_held == true) {
++		wchan_lock(lock->lk_wchan);
++		spinlock_release(&lock->lk_lock);
++		wchan_sleep(lock->lk_wchan);
++
++		spinlock_acquire(&lock->lk_lock);
++	}
++	KASSERT(lock->lk_held == false);
++	lock->lk_held = true;
++	lock->lk_holder = curthread;
++	spinlock_release(&lock->lk_lock);
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
+-        // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
++	KASSERT(lock != NULL);
++	//    KASSERT(lock_do_i_hold(lock));
++	spinlock_acquire(&lock->lk_lock);
++
++	lock->lk_held = false;
++	KASSERT(lock->lk_held == false);
++	wchan_wakeone(lock->lk_wchan);
++	lock->lk_holder = NULL;
++	spinlock_release(&lock->lk_lock);
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+-        // Write this
++	KASSERT(lock != NULL);
++	bool returnValue = false;
++	spinlock_acquire(&lock->lk_lock);
+ 
+-        (void)lock;  // suppress warning until code gets written
++	returnValue = lock->lk_held && (curthread == lock->lk_holder);
+ 
+-        return true; // dummy until code gets written
++	spinlock_release(&lock->lk_lock);
++	return returnValue;
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -213,55 +252,159 @@ lock_do_i_hold(struct lock *lock)
+ struct cv *
+ cv_create(const char *name)
+ {
+-        struct cv *cv;
+-
+-        cv = kmalloc(sizeof(struct cv));
+-        if (cv == NULL) {
+-                return NULL;
+-        }
+-
+-        cv->cv_name = kstrdup(name);
+-        if (cv->cv_name==NULL) {
+-                kfree(cv);
+-                return NULL;
+-        }
+-        
+-        // add stuff here as needed
+-        
+-        return cv;
++	struct cv *cv;
++
++	cv = kmalloc(sizeof(struct cv));
++	if (cv == NULL) {
++		return NULL;
++	}
++
++	cv->cv_name = kstrdup(name);
++	if (cv->cv_name==NULL) {
++		kfree(cv);
++		return NULL;
++	}
++
++	// add stuff here as needed
++
++	cv->cv_wchan=wchan_create(cv->cv_name);
++	if (cv->cv_wchan == NULL) {
++		kfree(cv->cv_name);
++		kfree(cv);
++		return NULL;
++	}
++	return cv;
+ }
+ 
+ void
+ cv_destroy(struct cv *cv)
+ {
+-        KASSERT(cv != NULL);
++	KASSERT(cv != NULL);
+ 
+-        // add stuff here as needed
+-        
+-        kfree(cv->cv_name);
+-        kfree(cv);
++	/* wchan_cleanup will assert if anyone's waiting on it */
++	wchan_destroy(cv->cv_wchan);
++	kfree(cv->cv_name);
++	kfree(cv);
+ }
+ 
+ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++	// Write this
++	KASSERT(cv != NULL);
++	KASSERT(curthread->t_in_interrupt == false);
++	wchan_lock(cv->cv_wchan);
++	lock_release(lock);
++	wchan_sleep(cv->cv_wchan);
++	lock_acquire(lock);
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+ {
+-        // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	(void)lock;
++	KASSERT(cv != NULL);
++	//lock_acquire(lock);
++	wchan_wakeone(cv->cv_wchan);
++	//lock_release(lock);
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
++	(void)lock;
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++	KASSERT(cv != NULL);
++	//lock_acquire(lock);
++	wchan_wakeall(cv->cv_wchan);
++	//lock_release(lock);
++
++}
++
++struct rwlock * rwlock_create(const char *name)
++{
++	struct rwlock *rwlk;
++
++
++	rwlk = kmalloc(sizeof(struct rwlock));
++	if (rwlk == NULL) {
++		return NULL;
++	}
++
++	rwlk->rwlock_name = kstrdup(name);
++	if (rwlk->rwlock_name == NULL) {
++		kfree(rwlk);
++		return NULL;
++	}
++
++	rwlk->writelock = lock_create(name);
++	if (rwlk->writelock == NULL) {
++		kfree(rwlk->rwlock_name);
++		kfree(rwlk);
++
++		return NULL;
++	}
++
++	rwlk->transactionlock = lock_create(name);
++	if (rwlk->transactionlock == NULL) {
++		kfree(rwlk->rwlock_name);
++		kfree(rwlk->writelock);
++		kfree(rwlk);
++		return NULL;
++	}
++
++	rwlk->cv_writer = cv_create(name);
++	if(rwlk->cv_writer == NULL)
++	{
++		kfree(rwlk->transactionlock);
++		kfree(rwlk->rwlock_name);
++		kfree(rwlk->writelock);
++		kfree(rwlk);
++		return NULL;
++	}
++	return rwlk;
++}
++void rwlock_destroy(struct rwlock *rwlk)
++{
++	kfree(rwlk->rwlock_name);
++	kfree(rwlk->writelock);
++	kfree(rwlk->transactionlock);
++	kfree(rwlk->cv_writer);
++	kfree(rwlk);
++}
++
++void rwlock_acquire_read(struct rwlock *rwlk)
++{
++	lock_acquire(rwlk->writelock);
++	lock_acquire(rwlk->transactionlock);
++	lock_release(rwlk->writelock);
++
++
++	rwlk->counter++;
++
++	lock_release(rwlk->transactionlock);
++}
++void rwlock_release_read(struct rwlock *rwlk)
++{
++	lock_acquire(rwlk->transactionlock);
++	rwlk->counter--;
++
++	if(rwlk->counter==0)
++		cv_signal(rwlk->cv_writer, rwlk->transactionlock);
++	lock_release(rwlk->transactionlock);
++}
++void rwlock_acquire_write(struct rwlock *rwlk)
++{
++	lock_acquire(rwlk->writelock);
++
++	lock_acquire(rwlk->transactionlock);
++
++	while(rwlk->counter != 0)
++		cv_wait(rwlk->cv_writer, rwlk->transactionlock);
++
++	lock_release(rwlk->transactionlock);
++}
++void rwlock_release_write(struct rwlock *rwlk)
++{
++	lock_release(rwlk->writelock);
+ }
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..ad47a06 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -154,6 +154,9 @@ thread_create(const char *name)
+ 
+ 	/* If you add to struct thread, be sure to initialize here */
+ 
++	//Anand: Setting exitCode to -999(Default) and initializing semaphore
++	//thread->exitSemaphore=sem_create("exitSemaphore",1);
++
+ 	return thread;
+ }
+ 
+@@ -176,7 +179,7 @@ cpu_create(unsigned hardware_number)
+ 	if (c == NULL) {
+ 		panic("cpu_create: Out of memory\n");
+ 	}
+-	
++
+ 	c->c_self = c;
+ 	c->c_hardware_number = hardware_number;
+ 
+@@ -261,6 +264,9 @@ thread_destroy(struct thread *thread)
+ 
+ 	/* sheer paranoia */
+ 	thread->t_wchan_name = "DESTROYED";
++	//Anand: destroying exitSempahore
++	//sem_destroy(thread->exitSemaphore);
++
+ 
+ 	kfree(thread->t_name);
+ 	kfree(thread);
+@@ -419,7 +425,7 @@ thread_start_cpus(void)
+ 
+ 	cpu_startup_sem = sem_create("cpu_hatch", 0);
+ 	mainbus_start_cpus();
+-	
++
+ 	for (i=0; i<cpuarray_num(&allcpus) - 1; i++) {
+ 		P(cpu_startup_sem);
+ 	}
+@@ -478,9 +484,9 @@ thread_make_runnable(struct thread *target, bool already_have_lock)
+  */
+ int
+ thread_fork(const char *name,
+-	    void (*entrypoint)(void *data1, unsigned long data2),
+-	    void *data1, unsigned long data2,
+-	    struct thread **ret)
++		void (*entrypoint)(void *data1, unsigned long data2),
++		void *data1, unsigned long data2,
++		struct thread **ret)
+ {
+ 	struct thread *newthread;
+ 
+@@ -523,6 +529,25 @@ thread_fork(const char *name,
+ 	/* Set up the switchframe so entrypoint() gets called */
+ 	switchframe_init(newthread, entrypoint, data1, data2);
+ 
++	int i;
++
++	//copy the filetable
++	for(i=0; i<OPEN_MAX; i++)
++	{
++		newthread->filetable[i] = curthread->filetable[i];
++		if(newthread->filetable[i]!=NULL && i>2)
++		{
++			newthread->filetable[i]->refcount++;
++		}
++	}
++
++	//assign pid and ppid
++	int newpid;
++	int err = createpid(newthread, &newpid);
++	if(err)
++		return err;
++	newthread->pid = newpid;
++	newthread->ppid = curthread->pid;
+ 	/* Lock the current cpu's run queue and make the new thread runnable */
+ 	thread_make_runnable(newthread, false);
+ 
+@@ -587,13 +612,13 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 
+ 	/* Put the thread in the right place. */
+ 	switch (newstate) {
+-	    case S_RUN:
++	case S_RUN:
+ 		panic("Illegal S_RUN in thread_switch\n");
+ 		break;
+-	    case S_READY:
++	case S_READY:
+ 		thread_make_runnable(cur, true /*have lock*/);
+ 		break;
+-	    case S_SLEEP:
++	case S_SLEEP:
+ 		cur->t_wchan_name = wc->wc_name;
+ 		/*
+ 		 * Add the thread to the list in the wait channel, and
+@@ -611,7 +636,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+ 		threadlist_addtail(&wc->wc_threads, cur);
+ 		wchan_unlock(wc);
+ 		break;
+-	    case S_ZOMBIE:
++	case S_ZOMBIE:
+ 		cur->t_wchan_name = "ZOMBIE";
+ 		threadlist_addtail(&curcpu->c_zombies, cur);
+ 		break;
+@@ -736,7 +761,7 @@ thread_switch(threadstate_t newstate, struct wchan *wc)
+  */
+ void
+ thread_startup(void (*entrypoint)(void *data1, unsigned long data2),
+-	       void *data1, unsigned long data2)
++		void *data1, unsigned long data2)
+ {
+ 	struct thread *cur;
+ 
+@@ -817,8 +842,9 @@ thread_exit(void)
+ 	/* Check the stack guard band. */
+ 	thread_checkstack(cur);
+ 
++
+ 	/* Interrupts off on this processor */
+-        splhigh();
++	splhigh();
+ 	thread_switch(S_ZOMBIE, NULL);
+ 	panic("The zombie walks!\n");
+ }
+@@ -845,14 +871,14 @@ thread_yield(void)
+ void
+ schedule(void)
+ {
+-  // 28 Feb 2012 : GWA : Leave the default scheduler alone!
++	// 28 Feb 2012 : GWA : Leave the default scheduler alone!
+ }
+ #else
+ void
+ schedule(void)
+ {
+-  // 28 Feb 2012 : GWA : Implement your scheduler that prioritizes
+-  // "interactive" threads here.
++	// 28 Feb 2012 : GWA : Implement your scheduler that prioritizes
++	// "interactive" threads here.
+ }
+ #endif
+ 
+@@ -947,8 +973,8 @@ thread_consider_migration(void)
+ 			t->t_cpu = c;
+ 			threadlist_addtail(&c->c_runqueue, t);
+ 			DEBUG(DB_THREADS,
+-			      "Migrated thread %s: cpu %u -> %u",
+-			      t->t_name, curcpu->c_number, c->c_number);
++					"Migrated thread %s: cpu %u -> %u",
++					t->t_name, curcpu->c_number, c->c_number);
+ 			to_send--;
+ 			if (c->c_isidle) {
+ 				/*
+@@ -1201,7 +1227,7 @@ interprocessor_interrupt(void)
+ 		spinlock_acquire(&curcpu->c_runqueue_lock);
+ 		if (!curcpu->c_isidle) {
+ 			kprintf("cpu%d: offline: warning: not idle\n",
+-				curcpu->c_number);
++					curcpu->c_number);
+ 		}
+ 		spinlock_release(&curcpu->c_runqueue_lock);
+ 		kprintf("cpu%d: offline.\n", curcpu->c_number);
+@@ -1228,3 +1254,5 @@ interprocessor_interrupt(void)
+ 	curcpu->c_ipi_pending = 0;
+ 	spinlock_release(&curcpu->c_ipi_lock);
+ }
++
++
+diff --git a/kern/vfs/vfspath.c b/kern/vfs/vfspath.c
+index 3e439c6..2ae3507 100644
+--- a/kern/vfs/vfspath.c
++++ b/kern/vfs/vfspath.c
+@@ -249,6 +249,34 @@ vfs_symlink(const char *contents, char *path)
+ 	return result;
+ }
+ 
++int vfs_read(struct vnode *vn, struct uio *uio)
++{
++		int result;
++		result = VOP_READ(vn, uio);
++
++//		VOP_DECREF(vn);
++
++		return result;
++}
++
++int vfs_write(struct vnode *vn, struct uio *uio)
++{
++		int result;
++		result = VOP_WRITE(vn, uio);
++
++		//VOP_DECREF(vn);
++
++		return result;
++}
++
++off_t vfs_lseek(struct vnode *vn, off_t pos)
++{
++	int result;
++	result = VOP_TRYSEEK(vn, pos);
++
++	return result;
++}
++
+ /*
+  * Does mo
\ No newline at end of file
diff --git a/user/testbin/badcall/bad_execv.c b/user/testbin/badcall/bad_execv.c
index 287a678..c0a6588 100644
--- a/user/testbin/badcall/bad_execv.c
+++ b/user/testbin/badcall/bad_execv.c
@@ -63,7 +63,7 @@ exec_common_fork(void)
 		return -1;
 	}
 	if (!WIFEXITED(status) || WEXITSTATUS(status) != MAGIC_STATUS) {
-		warnx("FAILURE: wrong exit code of subprocess");
+		warnx("FAILURE: wrong exit code of subprocess %d, %d, %d", status, WIFEXITED(status), WEXITSTATUS(status));
 	}
 	return 1;
 }
diff --git a/user/testbin/forktest/forktest.c b/user/testbin/forktest/forktest.c
index 50d72b0..c8599a6 100644
--- a/user/testbin/forktest/forktest.c
+++ b/user/testbin/forktest/forktest.c
@@ -41,6 +41,7 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <err.h>
+#include <errno.h>
 
 /*
  * This is used by all processes, to try to help make sure all
@@ -82,8 +83,8 @@ check(void)
 		seenpid = mypid;
 		if (seenpid != getpid()) {
 			errx(1, "pid mismatch (%d, should be %d) "
-			     "- your vm is broken!", 
-			     seenpid, getpid());
+			     "- your vm is broken! errno:%d",
+			     seenpid, getpid(), errno);
 		}
 	}
 }
@@ -170,7 +171,13 @@ int
 main(int argc, char *argv[])
 {
 	int nowait=0;
-
+//	char teststr[20];
+//	int k;
+//	for(k=0;k< 5; k++)
+//		teststr[k]=getchar();
+//	teststr[k]='\0';
+//	printf("%s", teststr);
+//	while(1);
 	if (argc==2 && !strcmp(argv[1], "-w")) {
 		nowait=1;
 	}
diff --git a/user/testbin/mytest/Makefile b/user/testbin/mytest/Makefile
new file mode 100644
index 0000000..7aa05e4
--- /dev/null
+++ b/user/testbin/mytest/Makefile
@@ -0,0 +1,11 @@
+# Makefile for fileonlytest
+
+TOP=../../..
+.include "$(TOP)/mk/os161.config.mk"
+
+PROG=mytest
+SRCS=mytest.c
+BINDIR=/testbin
+
+.include "$(TOP)/mk/os161.prog.mk"
+
diff --git a/user/testbin/mytest/mytest.c b/user/testbin/mytest/mytest.c
new file mode 100644
index 0000000..50cb971
--- /dev/null
+++ b/user/testbin/mytest/mytest.c
@@ -0,0 +1,43 @@
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <err.h>
+
+// 23 Mar 2012 : GWA : BUFFER_COUNT must be even.
+
+#define BUFFER_COUNT 128
+#define BUFFER_SIZE 128
+
+
+int
+main(int argc, char **argv)
+{
+
+	// 23 Mar 2012 : GWA : Assume argument passing is *not* supported.
+	
+	(void) argc;
+	(void) argv;
+	int fh, len;
+//	off_t pos, target;
+
+	const char * filename = "fileonlytest.dat";
+
+	// 23 Mar 2012 : GWA : Test that open works.
+(void)len;
+	printf("Opening %s\n", filename);
+
+	fh = open(filename, O_RDWR|O_CREAT|O_TRUNC);
+	if (fh < 0) {
+		err(1, "create failed");
+	}
+	
+	char buf[100];
+	sprintf(buf, "ech/o %d > debugfile", fh);
+	system(buf);
+
+  // 23 Mar 2012 : GWA : Do the even-numbered writes. Test read() and
+  // lseek(SEEK_END).
+ return 0;
+} 
